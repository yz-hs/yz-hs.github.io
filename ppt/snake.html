


<!DOCTYPE html>
<html>
<head>
	<title>Simple-PPT generated by Yurchiu</title>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<link rel="stylesheet" type="text/css" href="./css/base.css">
	<link rel="stylesheet" type="text/css" href="./css/extend.css">
	<link rel="stylesheet" type="text/css" href="./css/z-index.css">
	<link href="https://fonts.googleapis.com/css?family=Saira" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.15.6/katex.min.css">
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  	<script type="text/javascript" id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-svg-full.min.js"></script>
  	<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
  	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs2015.min.css">
</head>
<body>
	<div class="bg"></div>
	<script type="text/javascript">
		hljs.highlightAll();
	</script>
	<script>
		MathJax = {
  			tex: {
    			inlineMath: [['$', '$'], ['\\(', '\\)']]
  			},
  			svg: {
    			fontCache: 'global'
  			}
		};
	</script>
	<canvas id="myCanvas"></canvas>
	<script type="text/javascript" src="./js/keydown.js"></script>
	<script type="text/javascript" src="./js/paint.js"></script>
	<script type="text/javascript" src="./js/init.js"></script>
	<script type="text/javascript" src="./js/click.js"></script>
	

</div></div><div class="block" id="page1"><div class="poser"><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 1</div>


<topic>贪吃蛇 解题报告</topic><span class="tiny pos" style="right: 27%;top: 40%;">黑题++;</span>
<subtopic>博弈论+模拟</subtopic>

<p><img class="pos" style="right: 0;bottom: 0" src="./source/图片1.jpg"></img>

</p>
</div></div><div class="block" id="page2"><div class="poser"><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 2</div>


<click><p>&nbsp;</p><bg class="bg-black"></bg></click>
<click style="z-index: 2;"><span class="red">儒略</span>家的<span class="red">污水</span>冲刷 m 种颜色的各 n 个<span class="red">小球</span>，儒略很生气，就去广场刷<span class="red">微信步数</span>，看见广场上的<span class="red">贪吃蛇</span>在摆成 <span class="red">ABAB……C 状字符串</span>，他决定进行<span class="red">函数调用</span>解决这个问题。格里高利教皇看到这些蛇很不爽，于是把蛇都弄到了<span class="red">动物园</span>，并让儒略去购买饲料。这对儒略来说太难了，你能帮帮他吗？——2020 年 CSP-S & NOIP。</click>
<click class="mid white big" style="margin: auto;margin-top: 0%;z-index: 2;">等待你们的，将是一个 61 页的课件，一道黑题，一道 CSP-2020 的最后一题。</click>

<p><!--如何实现原动画（click 顺序）：2213-->

</p>
</div></div><div class="block" id="page3"><div class="poser"><h1 id="tag1">目录</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 3</div>
<ol><li> 前置知识
</li>
<li> 部分分的解
</li>
<li> 满分的解
</li>
<li> 后记
</li>
</ol>
<p><img class="pos" style="right: 0;top: 0" src="./source/图片2.jpg"></img>

</p>
</div></div><div class="block" id="page4"><div class="poser"><h1 id="tag2">前置知识-目录<span class="tiny">STL 杂讲</span></h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 4</div>
<ol><li> Deque 双端队列容器
</li>
<li> Set & multiset 集合和可重集合
</li>
<li> Pair 元素对
</li>
<li> Priority_queue 优先队列
</li>
<li> 运算符重载
</li>
<li> 什么是博弈论
</li>
</ol>
<p><br><br>

</p>
<p>由于作者水平有限，可能有错误，请批判地倾听。欢迎随时提出问题。

</p>
</div></div><div class="block" id="page5"><div class="poser"><h1 id="tag3">前置知识-Deque</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 5</div>
<p>Deque 是一个 STL 模板，是 double-ended queue 的缩写，双端队列。当需要向序列两端频繁地添加或删除元素时，应首选 deque 容器。<span class="red">不能保证所有元素都存储到连续的内存空间中</span>。

</p>
<p>如果要使用 deque，请包含以下代码：

</p>
<pre><code>#include &lt;deque&gt; 
//或者使用 &lt;bits/stdc++.h&gt; 
using namespace std;
deque&lt;int&gt;q; //定义
</code></pre>

</div></div><div class="block" id="page6"><div class="poser"><h1 id="tag4">前置知识-Deque</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 6</div>
<p>Deque 支持的操作如下。时间复杂度除了 clear 操作为 
$O(n)$ 外，其他均为 
$O(1)$。也<span class="red">支持随机访问</span>，时间复杂度也是 
$O(1)$。

</p>
<pre><code>q.front(); //返回队首元素。 
q.back(); //返回队尾元素。 
q.pop_front(); //返回队首元素。 
q.pop_back(); //返回队尾元素。 
q.push_front(x); //从队首压入元素 x。 
q.push_back(x); //从队尾压入元素 x。 
q.size(); //返回队列大小。 
q.clear(); //清空队列。 
q.empty(); //如果队列为空，返回 1。
</code></pre>

</div></div><div class="block" id="page7"><div class="poser"><h1 id="tag5">前置知识-Set & multiset</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 7</div>
<p>Set 和 multiset 是 STL 模板。Set 和 multiset 容器内的元素会被自动排序。Set 和 multiset中的元素既是键值又是实值。

</p>
<p>Set 不允许两个元素有相同的键值。而 multiset 允许。

</p>
<p>其内部实现是<span class="red">红黑树</span>（一种 BST）。

</p>
<p>如果要使用 set 和 multiset ，请包含以下代码：

</p>
<pre><code>#include &lt;set&gt; 
//或者使用 &lt;bits/stdc++.h&gt; 
using namespace std; 
set&lt;int&gt;q; //定义
multiset&lt;int&gt;q; //定义
</code></pre>

</div></div><div class="block" id="page8"><div class="poser"><h1 id="tag6">前置知识-Set & multiset</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 8</div>
<p>Set 和 multiset 支持以下操作。

</p>
<pre><code>s.begin() //返回指向第一个元素的迭代器 
s.clear(); // 清除所有元素 O(n)
s.count(x); //返回某个值元素的个数 O(log n)
s.empty(); //如果集合为空，返回 true 
s.end(); //返回指向最后一个元素之后的迭代器 
s.find(x); //返回一个指向被查找到元素的迭代器 O(log n) 
s.insert(x); //在集合中插入元素 
s.lower_bound(x); //返回指向大于等于某值的第一个元素的迭代器 
s.upper_bound(x); //返回大于某个值元素的迭代器，和上一个都是O(log n)
s.size(); //集合中元素的数目
</code></pre>

</div></div><div class="block" id="page9"><div class="poser"><h1 id="tag7">前置知识-Set & multiset</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 9</div>
<p>还有 erase 函数。其参数和 sort 函数类似，结合 sort 进行理解。

</p>
<pre><code>s.erase(iterator) //删除所指位置 
s.erase(first,second); // 删除 [first,second) 之间的数
s.erase(x); //删除值为 x 的数
</code></pre>

<p>另，若使用迭代器遍历，其遍历方式为中序遍历（即升序）。

</p>
<pre><code>set&lt;int&gt;::iterator it1 = s.begin(); //begin() 返回第一个元素地址
while (it1 != s.end()) //end() 返回最后一个元素的下一个地址
{ 
    cout &lt;&lt; *it1 &lt;&lt; " ";
    ++it1; 
}
</code></pre>

</div></div><div class="block" id="page10"><div class="poser"><h1 id="tag8">前置知识-Set & multiset</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 10</div>
<p>提示：一般情况下，STL 模板所传入的区间都是<span class="red">左闭右开</span>的。结合下图进行理解。

</p>
<p><img src="./source/图片17.png"></img>

</p>
<pre><code>set&lt;int&gt;::reverse_iterator it1 = s.rbegin(); //反向迭代器 
while (it1 != s.rend()) 
{ 
    cout &lt;&lt; *it1 &lt;&lt; " "; 
    ++it1; 
}
cout &lt;&lt; endl;
</code></pre>

</div></div><div class="block" id="page11"><div class="poser"><h1 id="tag9">前置知识-Set & multiset</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 11</div>
<p>或许可以在本题中可以方便地维护最值蛇？

</p>
<p>
<strong>由于 set 内部实现是一棵红黑树，想象一下它被拍扁了的样子，是不是像一个单调递增的“队列”一样呢？只是这“队列” 会自动维护单调性。另外，其遍历方式是<span class="red">中序遍历</span>，所以就能用 begin() 和 end() 来取出“队首”和“队尾”（注意 STL 的<span class="red">左闭右开</span>）。</strong>


</p>
<p>可以配合下面的 pair 来 insert ，处理体力和编号（还有一种做法后面讲）。

</p>
<p>不过 set 一般不当做队列来用。

</p>
</div></div><div class="block" id="page12"><div class="poser"><h1 id="tag10">前置知识-Pair</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 12</div>
<p>Pair 是一个 STL 模板。其使用 struct 实现。其将 2 个普通元素（两者数据类型不必相同） first 和 second 创建成一个新元素。

</p>
<p>如果要使用 pair，请包含以下代码：

</p>
<pre><code>#include &lt;utility&gt; 
//或者使用 &lt;bits/stdc++.h&gt; 
using namespace std; 
pair&lt;int,int&gt;p; //定义
</code></pre>

</div></div><div class="block" id="page13"><div class="poser"><h1 id="tag11">前置知识-Pair</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 13</div>
<p>以下为用例。

</p>
<pre><code>p=make_pair(x1,x2); //这个函数可生成一个 pair 
a=p.first; //返回第一个值 
b=p.second; //返回第二个值
</code></pre>

</div></div><div class="block" id="page14"><div class="poser"><h1 id="tag12">前置知识-Priority_queue </h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 14</div>
<p>
<del>毕竟大家都是写过 Dijkstra 最短路 + 优先队列优化的人，就不赘述了。</del>


</p>
<p>Priority_queue 是一个 STL 模板，其内部实现是堆。其数据自动按照堆的方式进行排列。

</p>
<p>其支持操作类似普通队列，只是 front() 改成了 top()。与不同队列不同的是，大多数操作都带 log。

</p>
<p>一般利用下面的运算符重载来规定优先级。

</p>
</div></div><div class="block" id="page15"><div class="poser"><h1 id="tag13">前置知识-运算符重载</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 15</div>
<p>在自己规定的数据类型（结构体）中，可以给数据之间定义运算。其语法和函数的定义类似。

</p>
<p>注意，如果在结构体内部进行定义，自身的成员使用 this 运算符（相当于结构体指针）进行访问。

</p>
<pre><code>struct Snakes{ 
	ll id,hp; 
	Snakes operator-(Snakes b){//内部定义 
		Snakes _t=*this; 
		_t.hp=this-&gt;hp-b.hp; 
		return _t; 
	} 
}; 
bool operator&lt;(Snakes a,Snakes b){//外部定义 
	if(a.hp==b.hp) return a.id&lt;b.id; 
	return a.hp&lt;b.hp; 
}
</code></pre>

</div></div><div class="block" id="page16"><div class="poser"><h1 id="tag14">前置知识-什么是博弈论</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 16</div>
<p>由于此题需要用到博弈论的思想，所以稍作介绍。

</p>
<p>博弈论主要研究的是：在一个游戏中，进行游戏的多位玩家的策略。

</p>
<p>可以看看这个课件：
<a href="https://yz-hs.github.io/media/博弈论入门_Yurchiu.pps" title="">Link</a>
。

</p>
</div></div><div class="block" id="page17"><div class="poser"><h1 id="tag15">部分分-目录</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 17</div>
<p>干货来了！

</p>
<ol><li> 题面
</li>
<li> 数据范围
</li>
<li> 20 分解
</li>
<li> 40 分解?
</li>
<li> 55 分解?
</li>
<li> 20 分解!
</li>
<li> 70 分解
</li>
</ol>
</div></div><div class="block" id="page18"><div class="poser"><h1 id="tag16">部分分-题面</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 18</div>
<p>草原上有 
$n$ 条蛇，编号分别为 
$1, 2, \ldots , n$。初始时每条蛇有一个体力值 
$a_i$，我们称编号为 
$x$ 的蛇实力比编号为 
$y$ 的蛇强当且仅当它们当前的体力值满足 
$a_x > a_y$，或者 
$a_x = a_y$ 且 
$x > y$。

</p>
<p>接下来这些蛇将进行决斗，决斗将持续若干轮，每一轮实力最强的蛇拥有选择权，可以选择吃或者不吃掉实力最弱的蛇：

</p>
<ol><li> 如果选择吃，那么实力最强的蛇的体力值将减去实力最弱的蛇的体力值，实力最弱的蛇被吃掉，退出接下来的决斗。之后开始下一轮决斗。
</li>
<li> 如果选择不吃，决斗立刻结束。
</li>
</ol>
<p>每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇（显然，蛇不会选择吃自己）。

</p>
<p>现在假设每条蛇都足够聪明，请你求出决斗结束后会剩几条蛇。

</p>
</div></div><div class="block" id="page19"><div class="poser"><h1 id="tag17">部分分-数据范围</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 19</div>
<p>对于 
$20 \%$ 的数据，
$n = 3$。  
<br />

</p>
<p>对于 
$40 \%$ 的数据，
$n \le 10$。  
<br />

</p>
<p>对于 
$55 \%$ 的数据，
$n \le 2000$。  
<br />

</p>
<p>对于 
$70\%$ 的数据，
$n \le 5 \times {10}^4$。  
<br />

</p>
<p>对于 
$100\%$ 的数据：
$3 \le n \le {10}^6$，
$1 \le T \le 10$，
$0 \le k \le {10}^5$，
$0 \le a_i, y \le 10^9$。保证每组数据（包括所有修改完成后的）的 
$a_i$ 以不降顺序排列。

</p>
</div></div><div class="block" id="page20"><div class="poser"><h1 id="tag18">部分分-20 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 20</div>
<p>N=3。直接看代码吧。并且跑得飞快。

</p>
<p>当年我的考场代码在 luogu 上提交好像只得了 10 分 qwq。

</p>
<pre><code>void _20pts() 
{ 
	if(s[3].hp-s[1].hp&gt;=s[2].hp) ans=1;
	else ans=3; //为什么比较要加等号？
	return; 
} //两行代码得 20 分，高效骗分。
</code></pre>

</div></div><div class="block" id="page21"><div class="poser"><h1 id="tag19">部分分-20 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 21</div>
<p>而思路更简单：看看最强蛇敢不敢吃。

</p>
<p>如果吃了，变成最弱的了，此时场上就只剩两条蛇了，它肯定就嗝屁了。此时它就不能吃，ans 的值就是 3。

</p>
<p>如果吃了，仍是最强的（由于之后场上只有两条蛇，要么最强，要么最弱），那它还能把另一条蛇吃了，那它肯定吃啊，ans 的值就是 1。

</p>
</div></div><div class="block" id="page22"><div class="poser"><h1 id="tag20">插播</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 22</div>
<p>到这里，有没有什么问题？请随便提问。下面是画图空间。我感觉这两行代码还是有很多“玄机”的。

</p>
</div></div><div class="block" id="page23"><div class="poser"><h1 id="tag21">部分分-20 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 23</div>
<p>关于等号：注意蛇的强弱还和编号有关，在体力相同的情况下，编号大的就强。所以即使 2 号和 3 号体力相等，3 号蛇还是最强的。

</p>
<p>也就是说，蛇的强弱是严格偏序关系（在 Yurchiu 写的满分代码中，运算符重载重载了 > 和 <，只是为了方便，实际上只需要其中一个即可）。

</p>
<p>只判断体力大小也是这个道理。

</p>
<p><br>

</p>
<p>为什么 ans 要么是 3 要么是 1：显然，当只有两条蛇时，更强的那个肯定会吃。

</p>
</div></div><div class="block" id="page24"><div class="poser"><h1 id="tag22">部分分-40 pts?</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 24</div>
<p>N=10。由于数据范围很小，似乎按照 20 分的思路乱搞就能随便过。

</p>
<pre><code>void solve40(Snakes tmp[]) 
{ 
	ans=n; 
	Snakes s[20]; 
	for(int i=1;i&lt;=n;i++) 
		s[i]=tmp[i]; //复制数组
	sort(s+1,s+1+ans,cmp); //无脑排序
	while(true) 
	{ 
		if(s[ans].hp-s[1].hp&gt;=s[2].hp) //判断这条蛇能不能吃 
			s[1].hp=s[ans].hp-s[1].hp,s[1].id=s[ans].id,ans--; 
		else break; //不能吃就跳出循环
		sort(s+1,s+1+ans,cmp); 
	} 
} 
</code></pre>

</div></div><div class="block" id="page25"><div class="poser"><h1 id="tag23">部分分-55 pts?</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 25</div>
<p>N=2000。似乎是 n 方算法。

</p>
<p>冷静分析一下：仍然承袭 20 分的思路，只需要每次找出最强蛇和最弱蛇，把它们的差和次弱蛇进行比较，如果比次弱蛇还弱就不吃了。反正则吃。

</p>
<p>所以，我们只需要动态维护最大值和最小值，并支持删除、插入。

</p>
<p>怎么办？

</p>
</div></div><div class="block" id="page26"><div class="poser"><h1 id="tag24">部分分-55 pts?</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 26</div>
<p>用 set 或优先队列维护最强蛇、最弱蛇和次弱蛇即可。

</p>
<p>Set 直接用，优先队列需要开两个。

</p>
<p><br>

</p>
<p>这样，连 n 方都不用，直接达到 
$n \log n$ 啊！

</p>
<p>
<del>诶，不就直接 70 分了啊！</del>


</p>
<p><br>

</p>
<p>
<del>看起来很和谐，这道题的部分分好好拿啊！</del>


</p>
</div></div><div class="block" id="page27"><div class="poser"><h1 id="tag25">插播</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 27</div>
<p>到这里，有没有什么问题？请随便提问。下面是画图空间。

</p>
</div></div><div class="block" id="page28"><div class="poser"><h1 id="tag26">部分分-55 pts?</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 28</div>
<p>然而按照这个思路打代码，交上去很可能就只有 20 分。

</p>
<p><img src="./source/图片3.png"></img>

</p>
<p>
<del>好耶！又水了一页课件！经典山东倒装。所以发现标题打上问号了吗？</del>


</p>
<p>
<del>实际上，部分分-40 pts? 里面的代码也是无法通过的。</del>


</p>
</div></div><div class="block" id="page29"><div class="poser"><h1 id="tag27">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 29</div>
<p>反思一下：我们是不是有一种情况没考虑到？当然了，
<del>要不为什么是 20 分啊。</del>


</p>
<p><br>

</p>
<p>比如说，如果吃后比次弱蛇还弱，就一定不吃吗？

</p>
<p>能不能举个例子？

</p>
<p><br>

</p>
<p>有的：3，4，5，6，10。

</p>
</div></div><div class="block" id="page30"><div class="poser"><h1 id="tag28">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 30</div>
<p>10 最强，肯定正常吃，因为吃后变成 7，没问题，仍最强。

</p>
<p><br>

</p>
<p>4，5，6，7。

</p>
<p><br>

</p>
<p>然后好像 7 就不能再吃了，因为吃后变成 3，是最弱蛇！

</p>
<p>然而，7 想，看看吃后会发生什么：

</p>
<p>：

</p>
<p>3，5，6。

</p>
<p><img class="pos" style="right:0;bottom:0;" src="./source/图片4.png"></img>

</p>
</div></div><div class="block" id="page31"><div class="poser"><h1 id="tag29">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 31</div>
<p>设 a 就是那个 6，b 就是原先的 7，变弱的 3。如果 a 敢把 b 吃了，场上就会变成这样：3，5。

</p>
<p><br>

</p>
<p>变最弱了！而此时 5（设它是 c）不会有什么顾忌，直接就把它吃了。于是，绝顶聪明的 a 肯定会想，不能吃 b 啊，也不敢吃 b 啊（题意：每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇）！

</p>
<p><br>

</p>
<p>所以，b 知道它变最弱后 a 不敢吃它，所以 b 就放心大胆地吃了。

</p>
<p>于是答案是 3。

</p>
</div></div><div class="block" id="page32"><div class="poser"><h1 id="tag30">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 32</div>
<p>再回想一下整个过程：10 吃了变成 7（b），接着看 b 能不能吃。

</p>
<p>c 一定吃 -> a 不能吃 -> b 一定吃。

</p>
<p>在思考这个过程时，需要一些博弈论的思想。

</p>
<p>按照原先的错误做法，答案就是 4 了。然而答案是 3。

</p>
<p>这就是为什么当年我们打 CSP-2020 最后一题时测大样例时总是和答案差 1。

</p>
<p><img class="pos" style="right:0;bottom:0;" src="./source/图片5.png"></img>

</p>
</div></div><div class="block" id="page33"><div class="poser"><h1 id="tag31">插播</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 33</div>
<p>到这里，有没有什么问题？请随便提问。下面是画图空间。

</p>
</div></div><div class="block" id="page34"><div class="poser"><h1 id="tag32">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 34</div>
<p>怎么办？

</p>
<p>难道需要对于每条蛇，都要模拟蛇的思维过程？

</p>
<p>所以这道题的模拟的性质体现于此。

</p>
<p><br>

</p>
<p>抛开刚才的例子，让我们从更一般的情况去讨论这道题。

</p>
</div></div><div class="block" id="page35"><div class="poser"><h1 id="tag33">部分分-20 pts!</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 35</div>
<p>发现我们问题的症结在于：如果吃后比次弱蛇还弱，是否还吃的问题。

</p>
<p><br>

</p>
<p>所以想到，把情况分为两类来讨论：

</p>
<p><br>

</p>
<ul><li> 当前最强的蛇吃了最弱的蛇之后，没有变成最弱的蛇。
</li>
<li> 当前最强的蛇吃了最弱的蛇之后，变成了最弱的蛇。
</li>
</ul>
</div></div><div class="block" id="page36"><div class="poser"><h1 id="tag34">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 36</div>
<p>
<del>前方核能！</del>


</p>
<p>首先，给出一个显然的结论：当前最强的蛇如果吃了最弱的蛇之后，没有变成最弱的蛇，它一定会选择吃。

</p>
<p><br>

</p>
<p>要证明这个结论，首先来个引理：如果蛇们按照规则一直吃，则吃完后的蛇是越来越弱的。即，若 
$a_i$ 比 
$a_j$ 先吃，则 
$a_i > a_j$。

</p>
<p>为什么呢？

</p>
<p><br>

</p>
<p>因为最强蛇一定不如以前强，最弱蛇一定不如以前弱。 

</p>
</div></div><div class="block" id="page37"><div class="poser"><h1 id="tag35">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 37</div>
<p>因而给出结论的证明：

</p>
<ul><li> 它如果吃了，仍最强，不吃白不吃；
</li>
<li> 它如果吃了，不是最强的，则根据引理，之后的蛇吃后，一定比它要弱，一定会想尽办法不死。  
<br />
</li>
</ul>
<p>因此不管如何，它一定死不了。

</p>
<p>所以它达到了“在自己不被吃的前提下在决斗中尽可能多吃别的蛇”的目的。

</p>
</div></div><div class="block" id="page38"><div class="poser"><h1 id="tag36">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 38</div>
<p>然而，还有一种情况：当前最强的蛇吃了最弱的蛇之后，变成了最弱的蛇！

</p>
<p>这时候，它吃不吃，取决于后面的蛇是否吃。

</p>
<p>就像原先的例子，推理一下： 

</p>
<ul><li> 如果 
$a_i$ 吃了，变成最弱蛇，而 
$a_j$ 再吃 
$a_i$ 后不是最弱蛇，则 
$a_j$ 一定吃，那 
$a_i$ 就死了，所以 
$a_i$ 不能吃。
</li>
<li> 如果 
$a_i$ 吃了，变成最弱蛇，而 
$a_j$ 再吃 
$a_i$ 后是最弱蛇，而 
$a_k$ 吃了 
$a_j$ 不是最弱蛇，则 
$a_k$ 一定吃，那 
$a_j$ 就死了，所以 
$a_j$ 不能吃。所以 
$a_i$ 能吃。
</li>
<li> 吃吃吃，如果最后场上只有两条蛇，则 
$a_i$ 无论如何都要吃。
</li>
</ul>
</div></div><div class="block" id="page39"><div class="poser"><h1 id="tag37">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 39</div>
<p>所以这个问题就变成了一个递归的问题，边界是一条蛇打破了第二阶段或场上只有两条蛇了。

</p>
<p>实际上，在程序设计时，<span class="red">不用真的写递归</span>，因为注意到 
$a_i$ 能不能吃和递归层数的奇偶性有关，只需<span class="red">一个循环</span>即可解决。

</p>
<p>这就叫：人理解循环，蛇理解递归。

</p>
</div></div><div class="block" id="page40"><div class="poser"><h1 id="tag38">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 40</div>
<p>所以，我们可以将整场决斗分为两个阶段。

</p>
<p>把“当前最强的蛇吃了最弱的蛇之后都没有变成最弱的蛇”这个阶段，定为第一阶段。所有最强蛇进食后都不是最弱蛇，放心大胆吃。

</p>
<p>把“当前最强的蛇吃了最弱的蛇之后都变成最弱的蛇”这个阶段，定为第二阶段。所有最强蛇进食后都是最弱蛇，直到有条蛇可以放心吃为止。

</p>
<p>如果决斗进行到第二阶段，整个决斗就接近结束了。第二阶段是为了判断能不能再吃一次。

</p>
<p>
<del>拿出打 Mayan 游戏的精神来，模拟吧！</del>


</p>
</div></div><div class="block" id="page41"><div class="poser"><h1 id="tag39">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 41</div>
<p>
<del>可以认为第一阶段是确确实实进行的，第二阶段是在蛇的大脑中进行的。</del>


</p>
<p>利用 set 可以方便地维护最强、最弱蛇。优先队列也可以做。利用 pair，可以实现编号和体力的一并存储（似乎自己定义结构体就可以了，并且是可以的
<del>毕竟 Yurchiu 就是自己定义的</del>
，实际上，STL 模板一些函数的返回值就是 pair）。

</p>
<p><br>

</p>
<p>忽略数据组数，时间复杂度是 
$O(n \log n)$。

</p>
</div></div><div class="block" id="page42"><div class="poser"><h1 id="tag40">部分分-70 pts</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 42</div>
<p>插一句：为什么下发 70 分代码（set 版）中似乎没有与次弱蛇比较的操作？

</p>
<p><br>

</p>
<p>因为如果它吃后变成最弱蛇，它一定是在 set 容器的末尾。此时只要判断末尾元素的编号是否等于它即可。

</p>
</div></div><div class="block" id="page43"><div class="poser"><h1 id="tag41">插播</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 43</div>
<p>到这里，有没有什么问题？请随便提问。下面是画图空间。

</p>
</div></div><div class="block" id="page44"><div class="poser"><h1 id="tag42">满分解-目录</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 44</div>
<ol><li> 发现单调性
</li>
<li> 代码实现
</li>
<li> 附注
</li>
</ol>
</div></div><div class="block" id="page45"><div class="poser"><h1 id="tag43">满分解-发现单调性</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 45</div>
<p>想想蚯蚓那道题，我们是用了 3 个队列来维护单调性的。

</p>
<p>而这道题有没有单调性呢？

</p>
<p><br>

</p>
<p>答案是有的！

</p>
<p>请思考一下，如何“自动”地维护单调性？能不能也通过设几个队列的方式来维护？

</p>
</div></div><div class="block" id="page46"><div class="poser"><h1 id="tag44">满分解-发现单调性</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 46</div>
<p>建立两个双端队列 q1 和 q2。q1 存储刚开始还没吃的蛇，q2 存储已经吃过的蛇（不是被吃的蛇）。

</p>
<p><br>

</p>
<ul><li> 对于 q1，单调性显然。
</li>
<li> 对于 q2，根据
<a href="#page37" title="">引理</a>
，也具有单调性。
</li>
</ul>
<p><br>

</p>
<p>所以就不用再使用带 log 的数据结构维护了。显然，时间复杂度是线性的。

</p>
</div></div><div class="block" id="page47"><div class="poser"><h1 id="tag45">满分解-代码实现<span class="tiny">Talk is cheap. Show me the code.屁话少说，放码过来！</span></h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 47</div>
<p>第一阶段：从 q1，q2 头部取出最强蛇，设为 G。G 要吃最弱蛇 L（从 q1 尾部取出），变成 T。

</p>
<p>判断 T 是不是最弱蛇。不是则把 T 压入 q2 尾部（单调性已证）。

</p>
<p>Q2 队列中的蛇在第一阶段一定不会被吃（取出）。如果被吃，则说明上一个 G 变成了最弱蛇，要进入第二阶段。

</p>
<pre><code>if(q1.size()+q2.size()&lt;=2) {ans=1;return;} //特判 
Snakes L=getB(),G=getF(); //Get Back/Front
Snakes T=(G-L); 
if(T&lt;q1.back() || q1.empty()) Stage_2(); 
else q2.push_back(T);
</code></pre>

</div></div><div class="block" id="page48"><div class="poser"><h1 id="tag46">满分解-代码实现</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 48</div>
<p>第二阶段：只需维护一个最弱蛇。不用再压入队列，因为第二阶段结束后整个决斗就停止了。并统计吃的次数。

</p>
<p>判断奇偶性，看能不能再吃一次。

</p>
<pre><code>if(T&lt;q1.back() || q1.empty()){//此时 T == L
 	ans=q1.size()+q2.size()+2;//答案不必动态统计。
 	while(true){ 
		cnt++;
 		if(q1.size()+q2.size()+1&lt;=2){
			ans-=(cnt%2==0);//奇偶性
			return;
		} 
		G=getF();T=(G-T); 
		if(T&gt;Check()){ans-=(cnt%2==0);return;} 
	}//Check 判断是不是最弱蛇（两个队列） 
}
</code></pre>

</div></div><div class="block" id="page49"><div class="poser"><h1 id="tag47">插播</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 49</div>
<p>到这里，有没有什么问题？请随便提问。下面是画图空间。

</p>
</div></div><div class="block" id="page50"><div class="poser"><h1 id="tag48">满分解-代码实现</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 50</div>
<p>然后输出 ans 就完了。

</p>
<p><img src="./source/图片6.png"></img>

</p>
</div></div><div class="block" id="page51"><div class="poser"><h1 id="tag49">满分解-附注</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 51</div>
<ul><li> 可以在 
<a href="https://yz-hs.github.io/c523eb585661/" title="">此</a>
 查看本题完整代码。
</li>
<li> 参考了题解 
<a href="https://www.luogu.com.cn/blog/wcsb/solution-p7078" title="">题解 P7078 【贪吃蛇（洛谷民间数据）】</a>
。
</li>
</ul>
</div></div><div class="block" id="page52"><div class="poser"><h1 id="tag50">后记-目录</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 52</div>
<p>大佬 zzy 的内容。

</p>
<p><br>

</p>
<ol><li> 处理蛇的大小进行比较其实还有一种方法
</li>
<li> 关于第二阶段的蛇的预判 
</li>
<li> 嗟夫！于是乎
</li>
<li> 花絮
</li>
<li> 鸣谢
</li>
</ol>
</div></div><div class="block" id="page53"><div class="poser"><h1 id="tag51">后记-处理蛇的大小进行比较其实还有一种方法</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 53</div>
<p>
<del>就是我了。</del>


</p>
<p>可能有人会问：我不会用运算符重定义怎么办啊？

</p>
<p><br>

</p>
<p>
<del>Yurchiu 运算符重定义写挂了导致晚上挑灯夜读题解。</del>


</p>
<p>
<del>毕竟人人都会有饭错的时候嘛。</del>


</p>
<p><br>

</p>
<p>
<del>数据结构不够，算法来凑。</del>


</p>
<p><span class="pos" style="right: 20%;bottom: 10%">我想对 Yurchiu 说：</span>

</p>
<p><img class="pos" style="bottom:0;right:0;" src="./source/图片7.jpg"></img>

</p>
</div></div><div class="block" id="page54"><div class="poser"><h1 id="tag52">后记-处理蛇的大小进行比较其实还有一种方法</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 54</div>
<p>考虑到蛇以体力为第一关键字，编号为第二关键字。

</p>
<p><br>

</p>
<p>我们可以通过状态压缩的方式
<del>像 dp 一样</del>
将蛇的大小乘上常数 1e9，再加上编号。

</p>
<p><br>

</p>
<p>于是就可以比较数字的大小来比较蛇的强弱啦。

</p>
<p><br>

</p>
<p>什么？这代码怎么用 int？→

</p>
<p><br>

</p>
<p>不开 long long 见祖宗，inf 的值设大些。

</p>
<p><img class="pos" style="bottom:0;right:0;" src="./source/图片8.png"></img>

</p>
</div></div><div class="block" id="page55"><div class="poser"><h1 id="tag53">后记-处理蛇的大小进行比较其实还有一种方法</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 55</div>
<p>比较的时候直接比较就可以了，然后我的代码就出锅了。为甚么？

</p>
<p>细节决定成败 （对我来说是血的教训）！

</p>
<p>注意到在比较蛇的大小的时候是三个蛇一起，并且我们是需要做减法的！

</p>
<p>这样会使得蛇的编号相减。大小相减不会出问题，但是编号就不是原来的编号了。

</p>
<p><img class="pos" style="bottom:0;right:0;" src="./source/图片9.png"></img>

</p>
</div></div><div class="block" id="page56"><div class="poser"><h1 id="tag54">后记-处理蛇的大小进行比较其实还有一种方法</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 56</div>
<p>怎么办呢？

</p>
<p><br>

</p>
<p>啊哈，之前 bfs 咱们是怎么做的呢！

</p>
<p><br>

</p>
<p>就是把一个数拆开再合并起来，利用 long long 自动向下取整。

</p>
<p><br>

</p>
<p>不仅在压入队列时需要这样，比较时也得这样。

</p>
<p><br>

</p>
<p>
<del>我自认为解决完了一个已知的错误，没想到不彻底，导致调了一上午。</del>


</p>
</div></div><div class="block" id="page57"><div class="poser"><h1 id="tag55">后记-关于第二阶段的蛇的预判 </h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 57</div>
<p>
<del>只是因为我比较懒。</del>


</p>
<p>场上只有一条蛇时一定会结束！

</p>
<p>蛇的体力值是可以为 0 的 （大小没了只剩编号的强度了）。

</p>
<p>既然我们知道是与回合的奇偶性有关，那么我们就可以引入玄学算法 （祝你 RP++）。

</p>
<p>我直接让回合数 mod 2 等于一个幸运数字 mod 2（不对就幸运数字 +1）。

</p>
</div></div><div class="block" id="page58"><div class="poser"><h1 id="tag56">后记-关于第二阶段的蛇的预判 </h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 58</div>
<p>蛇是绝顶聪明的 （要不为什么能暴打考场上的我们）。

</p>
<ol><li> 在这期间第一阶段剩下的蛇的数量就不要减了，因为我们是模拟的博弈（
<del>蛇大脑思考</del>
）的过程。
</li>
<li> 队列取空了就不要取了（否则就会像猪国杀那样只取最后的元素）。
</li>
<li> 第一阶段第二个队列的蛇是不会被吃掉的， 所以第二阶段的判断会比较的多 （当然第一阶段用第二阶段的选法是莫得问题的）。
</li>
</ol>
</div></div><div class="block" id="page59"><div class="poser"><h1 id="tag57">后记-嗟夫！于是乎</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 59</div>
<p>
<del>前 40 分与编号无关，不要问我怎么知道的。然而并不是。</del>


</p>
<p><img src="./source/图片10.png"></img>

</p>
</div></div><div class="block" id="page60"><div class="poser"><h1 id="tag58">后记-花絮</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 60</div>
<p>[图片] [图片] [图片] [图片] 
<del>懒得贴了</del>


</p>
<p>
<del>300多行的代码，因为带了注释所以很好理解。</del>


</p>
<p><br>

</p>
<p>长夜漫漫，Yurchiu 做伴！你学会了吗？不过，为啥 Yurchiu 的 PPT 像我的代码一样长啊（x —— z<span class="red">zy</span>

</p>
<p>这个题花了我两三天的时间（连带着参考题解）！然而 zzy 大佬独立完成了代码（300 多行，不过去掉注释及空行也就 100 多行）！ —— Yurchiu

</p>
</div></div><div class="block" id="page61"><div class="poser"><h1 id="tag59">后记-鸣谢</h1><div class="lfooter" onclick="left()"></div><div class="rfooter" onclick="right()">Page 61</div>
<ul><li> 感谢 z<span class="red">zy</span> 大佬甘愿把他的内容作为后记呈现！
</li>
<li> 感谢 z<span class="red">zy</span> 大佬提供的图片！
</li>
<li> 感谢这个活动，让我对这个题有了更深的理解，也学会了如何做 PPT！
</li>
<li> 感谢在座的每一个人听我这么烂的报告！
</li>
<li> 感谢出题人！
</li>
<li> 
<del>后来我又把它转成了 Simple-PPT 与原 PPT 做对比！</del>

</li>
</ul>
<p><p class="huge" style="margin:auto">感谢聆听！</p>

<img class="pos" style="bottom:0;right:0;" src="./source/图片18.jpg"></img>

</p>

</body></html>
</div></div><div class="block bg-black"><p class="mid micro white">放映结束，请关闭本标签。</p></div>
