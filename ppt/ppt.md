0

{sep}

</>
<topic>[Idea] 数字三角形</topic>
<subtopic>1s,256M,10KB</subtopic>
</>

# 题目背景

<wshady>Yurchiu 在上厕所时，在厕所地面砖的网格图案上找到了一个神奇的数字三角形！</wshady>

<wshady>至于为什么在厕所想到灵感，~~你猜~~。</wshady>

<wshady>原先本题只有一问。之后，在 Yurchiu 和 $\tt{zz}\omega$ 的努力下，使这个问题增加了三问！</wshady>

---

</>
<details>
<summary> 本题灵感来源 </summary>
<p>你把它当成一个平面直角坐标系，有很多斜着的平行的直线 $x+y+c=0$，如果把 $x$ 和 $y$ 乘起来，就形成了一个数字三角形。<p></details>
</>

# 题目描述

给定一个如下的数字三角形，共有无限行。其规律是：第 $i$ 列是公差为 $i+1$ 的等差数列，首项为 $2i+2$。

```
4
6 6
8 9 8
10 12 12 10
12 15 16 15 12
14 18 20 20 18 14
16 21 24 25 24 21 16
18 24 28 30 30 28 24 18
20 27 32 35 36 35 32 27 20
22 30 36 40 42 42 40 36 30 22
24 33 40 45 48 49 48 45 40 33 24
...
```

<click>记数字三角形第 $i$ 行，第 $j$ 列的数字为 $a_{i,j}$。例如，第 $7$ 行，第 $3$ 列的数字为 $24$。一个数 $x$ 存在于数字三角形，当且仅当存在一个数对 $(i,j)$，使得 $a_{i,j}=x$。</click>

<click>需要注意的是，数字三角形中有很多重复的数字，也有一些数字不存在。</click>

<click>现在，Yurchiu 和 $\tt{zz}\omega$ 给出 $Q$ 个询问，你均需要快速地回答。问题如下页。</click>

{sep}

询问一共有四种，分别是：

1. <click>Yurchiu 想要知道第 $x$ 行的和。答案对某个正整数 $p$ 取模。本询问分数占 $15\%$。</click>
2. <click>给定一个大于 $4$ 的正整数 $y$。如果不存在于数字三角形中，回答 `-1`。否则，显然这个数字可以由一个或多个数对 $(i,j)$ 对应。分别求 $\min\{a_{i+1,j+1}\}$ 的最小可能值和 $\max\{a_{i+1,j+1}\}$ 的最大可能值。Yurchiu 想要知道这个问题的答案。显然，$a_{i+1,j+1}$ 一定存在。本询问分数占 $21\%$。</click>
3. <click>给定一个坐标 $(b,d)$，其对应 $a_{b,d}$。保证 $b\ge d$。以这个坐标为起点，连续走 $k$ 步。$\tt{zz}\omega$ 想要分别知道可走到的最大值和最小值。“走一步”定义为使横坐标或纵坐标加一或减一，且保证走到的坐标合法。本询问分数占 $29\%$。</click>
4. <click>给定一个大于 $4$ 的正整数 $z$。如果不存在于数字三角形中，回答 `-1`。否则，回答 $\min\{a_{i,j-1},a_{i,j+1}\}$ 的最小可能值。Yurchiu 想要知道这个问题的答案。特别地，在本询问中，如果 $a_{i,j-1}$ 或 $a_{i,j+1}$ 不存在，则认为它的值为 $+\infty$。本询问分数占 $35\%$。</click>

询问的难度已按照 Yurchiu 主观顺序排序。询问的格式见下页。

# 输入输出格式

## 输入格式

第一行包含两个整数 $Q$ 和 $type$，表示询问的个数和询问类型。

接下来 $Q$ 行。对于询问 2 和 4，每行一个整数。对于询问 1，每行两个整数。对于询问 3，每行三个整数。

## 输出格式

输出 $Q$ 行。对于询问 1 和 4，每行一个整数。对于询问 2 和 3，每行两个整数。

特别地，如果答案是 `-1`，那么本行一个整数 `-1`。

{sep}

样例是挤在一块的。

## 样例输入

```
2 1
3 998244353
4 998244353
 
2 2
12
6
 
2 3
7 4 2
8 2 1
 
6 4
21
16
6
24
2333
40
```

## 样例输出

```
25
44
 
14 18
8 9
 
35 15
28 18
 
16
15
6
18
-1
33
```

# 提示

## 样例解释

样例 #2：第一个询问，$12$ 对应的数对有 $4$ 个，$a_{i+1,j+1}$ 的值可以是 $14$，$15$，$16$，$18$。

样例 #3：第二个询问，给定坐标对应的数是 $24$。向右走一步就可以到达最大值 $28$，向左走一步就可以到达最小值 $18$。

样例 #4：第二个询问，$16$ 对应的数对有 $3$ 个，$(a_{i,j-1},a_{i,j+1})$ 可以是 $(+\infty,21)$，$(15,15)$，$(21,+\infty)$。六个数中，最小的是 $15$。注：表示成括号的形式是为了方便理解，以上六个数是独立的。

## 数据范围

**测试点不等分**。对于每种询问，均有：

- 对于 $50\%$ 的数据，满足 $1\le Q\le {10}^3$。
- 对于 $100\%$ 的数据，满足 $1\le Q\le 5\times10^5$。

{sep}

特别地：

- 对于询问一，$1\le x,p\le 10^{16}$。对于 $50\%$ 的数据，$1\le x\le 10^3$。**注意，$p$ 不保证是质数。**
- 对于询问二，$5\le y\le 5\times10^6$。
- 对于询问三，$1\le b,d,k\le10^7$。对于 $50\%$ 的数据，$1\le k\le 50$。
- 对于询问四，$5\le z\le 5\times10^6$。

## 本题来源

- Idea：Yurchiu，$\tt{zz\omega}$。
- 其余：Yurchiu。

# 题解

这道题的难度大概只是 luogu 上的黄题左右。这道题数学味很冲，而且只是**小学**数学的水平，所以评为黄题。由于有四问，显然做题花费时间长，所以升为绿。虽然只是小学数学，但是的确有点麻烦，所以再升为蓝（实际上应为绿上位）。

<click>~~本题是不可多得的 adhoc 题。~~ 对于所有的问题，都是可以做到 $O(n)$ 预处理，$O(1)$ 回答的。</click>

{sep}

## 第一问

注意到**把第** $n$ **行的数字拆成两个因子相乘的形式之后，其和是定值** $n+3$。这个性质也是解决全部四问的关键，~~因为这是本题的 idea 核心所在。~~

令 $n=x+3$，则答案是：

<click>
$$
\begin{aligned}
S_x&=\left(\sum_{i=1}^ni(n-i)\right)-2(n-1)\\
   &=n\left(\sum_{i=1}^ni\right)-\left(\sum_{i=1}^ni^2\right)-2(n-1)\\
   &=\frac{1}{2}n^2(n+1)-\frac{1}{6}n(n+1)(2n+1)-2(n-1)\\
   &=\frac{1}{6}(n^3-13n+12)
\end{aligned}
$$

</click>

<click>然后我们就做完了？</click>

<click>但是注意到数字很大，一乘就会爆掉，无法应用第四个式子。并且模数 $p$ 不一定是质数，没法求逆元。用高精度呢，不仅麻烦，而且有 TLE 风险。我们只能对数进行手动除，配合龟速乘解决这一问。</click>

{sep}

如果直接应用第三个式子，那么有：

- $n,n+1$ 中必定有一个可以被 $2$ 整除的数。
- $n,n+1,2n+1$ 中必定有一个可以被 $3$ 整除的数。

那么，我们就可以在不爆掉的情况准确计算了。

<click>但是，这样常数大，容易 TLE。考虑对第四个式子进行等价变形：
$$
\begin{aligned}
S_x&=\frac{1}{6}(n^3-13n+12)\\
   &=\frac{1}{6}[n(n^2-1-12)+12]\\
   &=\frac{1}{6}n(n-1)(n+1)-2n+2\\
\end{aligned}
$$

</click><click>针对这个式子计算，常数会小很多。</click>

<click>但是还是 TLE。怎么办？这里提供一个小技巧。龟速乘的 base 可以调大一点。然后你就可以过掉最简单的第一问了。</click>

<click>注意：一定是除完之后，才能模 $p$。~~原先的数据是错的，原因就是这样先模再除产生的。~~</click>

但是终究还是太水了，所以给了 10 分。5 分是给直接暴力相加的。

{sep}

## 第二问

由于数字三角形的对称性，求 $a_{i+1,j+1}$ 的最值相当于求 $a_{i+1,j}$ 的最值。

<click>**数字三角形的第** $i$ **列是公差为** $i+1$ **的等差数列**。那么，首先得出的一个结论是：**一个数不存在于数字三角形等价于它是质数**。然后，你会发现 $a_{i,j}$ 与 $a_{i+1,j}$ 在同一列上。那就意味着，它们两个数在一个等差数列上。</click>

<click>显然，最小值是 $a_{i,j}$ 加最小可能公差。最小可能公差又等于 $a_{i,j}$ 的最小质因子。所以，只需要使用线性筛筛出每个数的最小质因子就行了。最大值，就是加最大因子，也就是加上 $a_{i,j}$ 除以最小质因子。</click>

<click>现在说明一下如何用线性筛求最小质因子。</click>

<click>考虑线性筛的时间复杂度是线性的特点。为什么时间复杂度是线性的的呢？原因是，合数被且仅被它的最小质因子筛掉。所以一个数被筛掉时，顺便就可以记录下来它的最小质因子。</click>

<click>另外，一个事实是，线性筛中，当满足 `i%prime[j]==0` 时，就要 `break`。其原因就是此时 `i*prime[j]` 的最小质因子就是 `prime[j]`。如果继续枚举质数，那么接下来的数 `i*prime[j+1]` 的最小质因子就不是 `prime[j+1]` 了，那么线性复杂度就无法保证。</click>

简单不简单？

{sep}

## 第三问

有点复杂。显然，活动的范围是和 $k$ 有关的菱形框。下图展示以 $(8,4)$ 为起点， $k=3$ 时的活动范围（其外围的一圈数字也在范围内）。

```
4
6 6
8 9 8
10 12 12 10
12 15 16 15 12
14 18 20    18 14
16 21          21 16
18       30       24 18
20 27          35 32 27 20
22 30 36    42 42 40 36 30 22
24 33 40 45 48 49 48 45 40 33 24
...
```

{sep}

考虑以下不等式：
$$
\large\begin{aligned}
\large a_{i,j}&< a_{i+1,j}\\
       a_{i,j}&< a_{i+1,j+1}
\end{aligned}
$$
这两个不等式来自于等差数列的性质和对称性。

<click>很自然地推出，在菱形框内的任意一个位置，都可以构造一条路径，到达框的右下边，且路径上的值递增。也就是说，整个框的最大值位于右下边。同理，最小值位于左上边，这里仅以最大值为例，最小值是同理的。</click>

<click>显然，边所在直线的斜率绝对值都等于 $1$。所以，可以考虑以下做法：</click>

<click>为了便于描述以及符合数学的习惯，横线表示为 $y=\lambda$，竖线表示为 $x=\mu$，其中 $\lambda$ 为行号，$\mu$ 为列号。</click>

<click>设直线 $l:x-y+m=0$，其中 $m$ 为直线 $x=1$ 与 $l$ 交点的横坐标。设函数 $f_m(z)$ 为 $l$ 与直线 $x=z$ 的交点所在方格的 $a$ 值。</click>

{sep}

令 $n=m+3$。利用因子和为定值的性质，可以得到：
$$
\large\begin{aligned}
f_m(z)&=(z+1)(n-2z)\\
      &=-2z^2+(n-2)z+n\\
      &=-2z^2+(m+1)z+m+3
\end{aligned}
$$
这是一个开口朝下的二次函数，所以有最大值。当 $z=-\dfrac{b}{2a}=\dfrac{m+1}{4}$ 时，$f_m(z)$ 取到最大值。

<click>但是，方框的边不是直线而是线段，所以要注意定义域。对于询问 $((b,d),k)$，易得 $m=b+d-1+k$，并且 $z\in[d,d+k]$。由于取最大值时 $z$ 不一定是整数，所以只需要取其上取整和下取整时函数值的最大值即可；注意不要超出定义域。对于最小值，取定义域 $[d-k,d]$ 的边界 $d-k$ 和 $d$ 的函数值最小值。</click>

<click>另外，注意求最小值时，如果 $m\le0$，那么最小值就是 $4$。</click>

所以，这道数学题就做完了。~~但还是很水。~~

{sep}

## 第四问

不妨设 $z=a_1b_1=a_2b_2$。其中，$a_1< a_2,b_1> b_2,a_i< b_i,i\in\{1,2\}$。

<click>显然题目要求的是 $(a_i-1)(b_i+1)$ 与 $(a_i+1)(b_i-1)$ 两者的最小值。</click>

<click>由于 $a_i< b_i$，所以 $(a_i-1)(b_i+1)\le(a_i+1)(b_i-1)$（因为 $a_i+b_i$ 是定值，根据均值不等式易得此结论）。那么，我们就只考虑求 $(a_i-1)(b_i+1)$ 的最小值就可以了。现在，让我们比较 $(a_1-1)(b_1+1)$ 和 $(a_2-1)(b_2+1)$  的大小关系。</click>

<click>利用作差法，得：
$$
\large\begin{aligned}
 &\ (a_2-1)(b_2+1)-(a_1-1)(b_1+1)\\
=&\ a_2b_2+a_2-b_2-1-a_1b_1-a_1+b_1+1\\
=&\ (a_2-a_1)-(b_2-b_1)\\
>&\ 0
\end{aligned}
$$
</click>

<click>所以，当 $a_i$ 取最小值（不能是 $2$）时，$(a_i-1)(b_i+1)$ 最小。现在，问题转化为求一个数的最小非 $2$ 因子。</click>

{sep}

首先还是需要使用线性筛筛出每个数的最小质因子。之后，从 $4$ 枚举到最大值，如果数 $i$ 的最小质因子 $m_i$ 是 $2$，就令 $m_i=m_{i/2}$。这样搞一遍，求得的是最小非 $2$ 质因子。

<click>再来一个循环，看是否能被 $4$ 整除且不是 $3$ 的倍数。如果是，那么这个数的最小非 $2$ 因子应该是 $4$。这样，这道题就做完了。</click>

<click>注意，如果一个数只能分解为 $2$ 乘一个质数，那没办法，只能是取 $(a_i+1)(b_i-1)$ 型。</click>

好像压轴问也没有那么难？~~可能是结论很好猜。~~

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace _yz
{
	typedef long long ll;
	const ll N=5000000+10,inf=214748364799999999;
	ll n,x,ans,flag,p[N],m[N],m2[N],cnt=0,Q;
	char t[N];
	void Prime()
	{
		for(ll i=2;i<=N-10;i++)
		{
			if(t[i]==0) p[++cnt]=i,m[i]=i;
			for(ll j=1;i*p[j]<=N-10&&j<=cnt;j++)
			{
				t[i*p[j]]=1; m[i*p[j]]=p[j];
				if(i%p[j]==0) break; 
			}
		}
		m[1]=1;
	}
	void init()
	{
		for(ll i=1;i<=N-10;i++) m2[i]=m[i];
		for(ll i=4;i<=N-10;i++)
			if(m2[i]%2==0) m2[i]=m2[i/2]; 
		for(ll i=1;i<=N-10;i++)
			if(i%4==0&&m2[i]!=3) m2[i]=4;
	}
	ll mul(ll a,ll b,ll p)
	{
		ll ret=0;
		if(a<b) swap(a,b);
		a%=p; b%=p;
		while(b)
		{
			if(b%4==1) ret=(ret+a)%p;
			else if(b%4==2) ret=(ret+a+a)%p;
			else if(b%4==3) ret=(ret+a+a+a)%p;
			b/=4; a=(a+a+a+a)%p;
		}
		return ret;
	}
	ll mul(ll a,ll b)
	{
		ll ret=0;
		if(a<b) swap(a,b);
		while(b)
		{
			if(b%4==1) ret=(ret+a);
			else if(b%4==2) ret=(ret+a+a);
			else if(b%4==3) ret=(ret+a+a+a);
			b/=4; a=(a+a+a+a);
		}
		return ret;
	}
	void solve1()
	{
		ll x,p,f1,f2,f3,ans;
		while(Q--)
		{
			ans=0;
			scanf("%lld%lld",&x,&p);
			x+=3; f1=x,f2=x+1,f3=x-1;
			if(f1%3==0) f1/=3;
			else if(f2%3==0) f2/=3;
			else f3/=3;
			if(f1%2==0) f1/=2;
			else f2/=2;
			ans=mul(mul(f1,f2,p),f3,p);
			ans=(ans-mul(x,2,p)+2)%p;
			printf("%lld\n",(ans%p+p)%p); 
		}
	}
	void solve2()
	{
		ll x;
		while(Q--)
		{
			scanf("%lld",&x);
			if(m[x]==x) printf("-1\n"); 
			else printf("%lld %lld\n",x+m[x],x+x/m[x]);
		}
		return;
	}
	ll F(ll z,ll m)
	{
		ll ret=-mul(2,mul(z,z));
		ret=ret+mul(m+1,z);
		ret=ret+m+3;
		return ret;
	}
	ll Max(ll L,ll R,ll m)
	{
		ll Lpos=floor((m+1)*1.0/4),Rpos=ceil((m+1)*1.0/4);
		ll ret=-inf;
		if(L<=Lpos&&Lpos<=R) ret=max(ret,F(Lpos,m));
		if(L<=Rpos&&Rpos<=R) ret=max(ret,F(Rpos,m));
		ret=max(ret,F(L,m)); ret=max(ret,F(R,m));
		return ret;
	}
	ll Min(ll L,ll R,ll m)
	{
		ll ret=inf;
		ret=min(ret,F(L,m)); ret=min(ret,F(R,m));
		return ret;
	}
	void solve3()
	{
		ll b,d,k,m;
		while(Q--)
		{
			scanf("%lld%lld%lld",&b,&d,&k);
			m=b+d-1+k;
			printf("%lld ",Max(d,min(d+k,b),m));
			m=b+d-1-k;
			if(m<=0) printf("4\n"); 
			else printf("%lld\n",Min(max(0ll,d-k),min(d,(ll)ceil(1.0*m/2)),m));
		}
		return;
	}
	void solve4()
	{
		ll x;
		while(Q--)
		{
			scanf("%lld",&x);
			if(m2[x]==x) printf("-1\n");
			else if(m2[x]==x/2) printf("%lld\n",3ll*(m2[x]-1));
			else printf("%lld\n",(m2[x]-1)*(x/m2[x]+1));
		}
		return;
	}
	void main()
	{
		int type;
		Prime(); init();
		scanf("%lld%d",&Q,&type);
		if(type==1) solve1();
		if(type==2) solve2();
		if(type==3) solve3();
		if(type==4) solve4();
		return;
	}
}
int main()
{
	freopen("triangle.in","r",stdin);
	freopen("triangle.out","w",stdout);
	_yz::main();
	return 0;
}
```
