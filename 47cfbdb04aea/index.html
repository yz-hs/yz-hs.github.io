<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="msvalidate.01" content="A7B4DB5A7BF5E5C6E52E34BB024D6319"><meta name="description" content="本站为 Yurchiu 用来记录 OI、笔记、感想的 Blog，欢迎来到本博客！希望我们能相互交流，共同进步～"><meta http-equiv="content-language" content="zh-cn"><title>一些关于 LCA 的题目 | Yurchiu's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/limonte-sweetalert2/11.4.17/sweetalert2.all.min.js"></script><script src="https://cdn.staticfile.org/sketch.js/1.0/sketch.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/chaffle.min.js"></script><script src="/js/core/main.js"></script><script src="/js/core/search.js"></script><script src="/js/core/initialization.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/katex.min.css"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs2015.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/colors/std.css"><link rel="stylesheet" href="/css/colors/white.css"><link rel="stylesheet" href="/css/colors/night.css"><link rel="stylesheet" href="/css/colors/trans.css"><link rel="stylesheet" href="/css/special/special.css"><link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Yurchiu's Blog" type="application/atom+xml"></head><body style="background-image:url(/img/new-bgp.png)"><div id="YurLoading" class="YurLoading"><div class="inner"><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div></div></div><div class="topbar"><a onclick="topbarToggle()" class="topbar-menu" style="cursor:pointer"><i class="fa fa-bars"></i> </a><a href="/" class="topbar-title"><i class="fa fa-home"></i> Yurchiu's Blog </a><a target="_blank" rel="noopener" href="https://github.com/yz-hs" class="topbar-title"><i class="fa fa-github"></i></a></div><div id="article-container"><div class="sidebar"><div class="avatar-container"><img src="/img/new-avatar.jpg" class="avatar revolve"></div><div class="sidebar-author">Yurchiu<br><span class="mini-text">An AFO whker.</span></div><div class="sidebar-list-container"><div style="height:10px"></div><a class="list-group-item" href="/"><div><i class="fa fa-home fa-fw"></i>&nbsp; 首页</div><div class="badge"></div></a><a class="list-group-item" href="/archives/"><div><i class="fa fa-tasks fa-fw"></i>&nbsp; 归档</div><div class="badge">159</div></a><a class="list-group-item" href="/tags/"><div><i class="fa fa-tags fa-fw"></i>&nbsp; 标签</div><div class="badge">81</div></a><a class="list-group-item" href="/categories/"><div><i class="fa fa-th-large fa-fw"></i>&nbsp; 分类</div><div class="badge">24</div></a><a class="list-group-item" href="/somepage/mood/"><div><i class="fa fa-photo fa-fw"></i>&nbsp; 说说</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/about/"><div><i class="fa fa-user-o fa-fw"></i>&nbsp; 关于</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/chat/"><div><i class="fa fa-commenting-o fa-fw"></i>&nbsp; 留言</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/link/"><div><i class="fa fa-link fa-fw"></i>&nbsp; 链接</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/settings/"><div><i class="fa fa-cog fa-fw"></i>&nbsp; 设置</div><div class="badge"></div></a><div style="height:200px"></div></div><div class="sidebar-footer"><div class="item" id="back2Top" data-bs-toggle="tooltip" title="顶部"><i class="fa fa-arrow-circle-up"></i></div><div class="item" id="back2Down" data-bs-toggle="tooltip" title="底部"><i class="fa fa-arrow-circle-down"></i></div><div class="item" data-bs-toggle="tooltip" title="RSS"><a href="/atom.xml"><i class="fa fa-feed"></i></a></div><div class="item" data-bs-toggle="tooltip" title="搜索"><a href="/somepage/search/"><i class="fa fa-search"></i></a></div></div></div><div class="article"><div class="vertical fake-sidebar"></div><div class="vertical post"><div class="header"><h1 class="title">一些关于 LCA 的题目</h1><div class="meta"><span><i class="fa fa-user-o"></i> Yurchiu </span><span><i class="fa fa-clock-o"></i> 2021-02-24, 18:05:31</span> <span><i class="fa fa-font"></i> 3.6k</span> <span class="hideBars" onclick="hideBars()"><i class="fa fa-eye-slash"></i> 隐藏左右两栏 </span><span class="showBars" onclick="showBars()"><i class="fa fa-eye"></i> 展示左右两栏</span></div></div><div class="breadcrumb"><div class="url"><a href="/"><i class="fa fa-home"></i> 首页</a> / 一些关于 LCA 的题目</div><div class="share">分享到 <a target="_blank" rel="noopener" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yz-hs.github.io/47cfbdb04aea/&title=一些关于 LCA 的题目&site=https://yz-hs.github.io"><i class="fa fa-qq"></i></a></div></div><div class="post-text"><p>这里是一些关于 LCA 的题目。</p><h1 id="p3398-仓鼠找sugar"><a class="markdownIt-Anchor" href="#p3398-仓鼠找sugar"></a> P3398 仓鼠找sugar</h1><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>在一棵有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）个节点的树上，有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">\le10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）个询问，每次询问两个点对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c,d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> 之间的最短路径的点集是否有交。</p><details><summary>点击查看题解</summary><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p><strong>若树上两条路径相交，则其中一条路径的 LCA 一定在另一条路径上</strong>。</p><p>一个感性的解释：设树根在你所画的图的最上面，若不满足上述条件，则两条路径一定是交叉的，成 <code>X</code> 或 <code>Y</code> 形，这显然跟树的定义不符（一个点仅有一个前驱）。</p><p>然后就是判断其中一条路径的 LCA 是否在另一条路径上了。一个判断的依据：一个点若在一条路径上，则这个点到路径左端点的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">+</span></span></span></span> 这个点到路径右端点的距离 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span></span></span></span> 这个路径的长度。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500000</span>+<span class="hljs-number">10</span>,Log=<span class="hljs-number">20</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
	<span class="hljs-type">int</span> n,Root,Q,cnt=<span class="hljs-number">0</span>,d[N],head[N],f[Log+<span class="hljs-number">5</span>][N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;e[++cnt]=(edge)&#123;head[a],b&#125;;head[a]=cnt;&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[root];i;i=e[i].nxt)
		&#123;
			<span class="hljs-type">int</span> son=e[i].to;
			<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>][root]==son) <span class="hljs-keyword">continue</span>;
			d[son]=d[root]+<span class="hljs-number">1</span>;f[<span class="hljs-number">0</span>][son]=root;<span class="hljs-built_in">dfs</span>(son);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>
	</span>&#123;
		d[Root]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(Root);f[<span class="hljs-number">0</span>][Root]=Root;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Log;i++)
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
				f[i][j]=f[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
		<span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Log;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-keyword">if</span>(d[f[i][x]]&gt;=d[y]) x=f[i][x];
		<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Log;i&gt;=<span class="hljs-number">0</span>;i--)
			<span class="hljs-keyword">if</span>(f[i][x]!=f[i][y]) 
				x=f[i][x],y=f[i][y];
		<span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
		<span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>,lca=<span class="hljs-built_in">LCA</span>(x,y);
		ret+=<span class="hljs-built_in">abs</span>(d[x]-d[lca]);
		ret+=<span class="hljs-built_in">abs</span>(d[y]-d[lca]);
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-type">int</span> t1,t2,t3,t4,l12,l34;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;Q);Root=<span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2),<span class="hljs-built_in">add</span>(t1,t2),<span class="hljs-built_in">add</span>(t2,t1);
		<span class="hljs-built_in">init</span>();
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;i++)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;t3,&amp;t4);
			l12=<span class="hljs-built_in">LCA</span>(t1,t2),l34=<span class="hljs-built_in">LCA</span>(t3,t4);
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dis</span>(t3,t4)==<span class="hljs-built_in">dis</span>(t3,l12)+<span class="hljs-built_in">dis</span>(l12,t4) ||
			   <span class="hljs-built_in">dis</span>(t1,t2)==<span class="hljs-built_in">dis</span>(t1,l34)+<span class="hljs-built_in">dis</span>(l34,t2) )
		         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Y\n&quot;</span>);		
			<span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;N\n&quot;</span>); 	
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

</code></pre></details><h1 id="p1967-noip2013-提高组-货车运输"><a class="markdownIt-Anchor" href="#p1967-noip2013-提高组-货车运输"></a> P1967 [NOIP2013 提高组] 货车运输</h1><h2 id="题意-2"><a class="markdownIt-Anchor" href="#题意-2"></a> 题意</h2><p>是文章<a href="/0cd5e6b46a46">最小生成树 2</a> 中的题目 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1396">P1396 营救</a>的“加强版”。1 万个点，5 万个边，有 3 万次询问，每次给定两点，求它们之间的一条路径，令路径上的最小边权最大。输出此路径最小边权。即，求两点最大瓶颈路的瓶颈。</p><details><summary>点击查看题解</summary><h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2><p><s>由于本题，这篇文章的标签才多了个“最小生成树”。</s></p><p>类似“营救”一题地，先构建最大生成树，按这棵树建新图。但这样要是在这个图上随便搜索一下就超时了。考虑加速求一条路径的最小边权。注：可以将边权转化为点权。</p><p>我们使用倍增来加速。先钦定每个连通块（图不一定连通）的一个节点为根。此时每条路径就相当于左端点到 LCA 的路径加右端点到 LCA 的路径。设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">)</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span></span></span></span> 点向上跳 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.824664em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span> 个点所经过点权的最小值。状态转移方程和求 LCA 用的倍增数组类似，可见代码。当我们求两点的 LCA 时，我们也可以顺带求得最小值。</p><p>如何判断无解：只要看看两点是否在一个连通块中即可。</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">50000</span>+<span class="hljs-number">10</span>,N=<span class="hljs-number">10000</span>+<span class="hljs-number">10</span>,Inf=<span class="hljs-number">2147483647</span>/<span class="hljs-number">2</span>,V=<span class="hljs-number">17</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Road</span>&#123;<span class="hljs-type">int</span> u,v,len;&#125;road[M];
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> nxt,to,len;&#125;e[M*<span class="hljs-number">2</span>];
		<span class="hljs-type">int</span> head[N],cnt;
		<span class="hljs-built_in">Graph</span>()&#123;<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));cnt=<span class="hljs-number">0</span>;&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;e[++cnt]=(edge)&#123;head[a],b,c&#125;;head[a]=cnt;&#125;
	&#125;Tree;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
	&#123;
		<span class="hljs-type">int</span> dad[M],n;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
		</span>&#123;  
    		<span class="hljs-type">int</span> root=x;  
    		<span class="hljs-keyword">while</span>(root!=dad[root])
        		root=dad[root];
    		<span class="hljs-keyword">return</span> root;  
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union_</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
		</span>&#123;
    		<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		dad[d1]=d2;
    		<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
		</span>&#123;
    		<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		<span class="hljs-keyword">if</span>(d1==d2)
        		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
	&#125;ufds;
	<span class="hljs-type">int</span> n,m,Q,s,t,f[V+<span class="hljs-number">5</span>][N],d[N],A[V+<span class="hljs-number">5</span>][N];
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Road a,Road b)</span></span>&#123; <span class="hljs-keyword">return</span> a.len&gt;b.len; &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span>
	</span>&#123;
    	<span class="hljs-type">int</span> num=<span class="hljs-number">0</span>,ru,rv; 
    	<span class="hljs-built_in">sort</span>(road+<span class="hljs-number">1</span>,road+m+<span class="hljs-number">1</span>,cmp);
    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
    	&#123;
       		ru=ufds.<span class="hljs-built_in">find</span>(road[i].u),rv=ufds.<span class="hljs-built_in">find</span>(road[i].v);
        	<span class="hljs-keyword">if</span>(ru==rv)
            	<span class="hljs-keyword">continue</span>;
			Tree.<span class="hljs-built_in">add</span>(road[i].u,road[i].v,road[i].len);
			Tree.<span class="hljs-built_in">add</span>(road[i].v,road[i].u,road[i].len);
			ufds.<span class="hljs-built_in">union_</span>(ru,rv);
        	<span class="hljs-keyword">if</span>(++num==n<span class="hljs-number">-1</span>)
            	<span class="hljs-keyword">break</span>;
    	&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now)</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Tree.head[now];i;i=Tree.e[i].nxt)
		&#123;
			<span class="hljs-type">int</span> to=Tree.e[i].to,len=Tree.e[i].len;
			<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>][now]!=to)
				d[to]=d[now]+<span class="hljs-number">1</span>,f[<span class="hljs-number">0</span>][to]=now,A[<span class="hljs-number">0</span>][to]=len,<span class="hljs-built_in">dfs</span>(to);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span>
	</span>&#123;
		<span class="hljs-type">int</span> ret=Inf;
		<span class="hljs-keyword">if</span>(d[u]&gt;d[v]) <span class="hljs-built_in">swap</span>(u,v);
		<span class="hljs-type">int</span> tmp=d[v]-d[u];
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=V;i&gt;=<span class="hljs-number">0</span>;i--)
			<span class="hljs-keyword">if</span>(tmp&gt;=(<span class="hljs-number">1</span>&lt;&lt;i))
				ret=<span class="hljs-built_in">min</span>(ret,A[i][v]),v=f[i][v],tmp-=(<span class="hljs-number">1</span>&lt;&lt;i);
		<span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> ret;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=V;i&gt;=<span class="hljs-number">0</span>;i--)
			<span class="hljs-keyword">if</span>(f[i][u]!=f[i][v])
				ret=<span class="hljs-built_in">min</span>(ret,<span class="hljs-built_in">min</span>(A[i][u],A[i][v])),
				u=f[i][u],v=f[i][v];
		<span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(ret,<span class="hljs-built_in">min</span>(A[<span class="hljs-number">0</span>][u],A[<span class="hljs-number">0</span>][v]));
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-type">int</span> ta,tb,tc;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;ta,&amp;tb,&amp;tc),
			road[i]=(Road)&#123;ta,tb,tc&#125;;
		ufds.<span class="hljs-built_in">init</span>(n);<span class="hljs-built_in">kruskal</span>();
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			<span class="hljs-keyword">if</span>(ufds.dad[i]==i) f[<span class="hljs-number">0</span>][i]=i,A[<span class="hljs-number">0</span>][i]=<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(i);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=V;i++)
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
				f[i][j]=f[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]],
				A[i][j]=<span class="hljs-built_in">min</span>(A[i<span class="hljs-number">-1</span>][j],A[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]]);
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Q);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;i++)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);
			<span class="hljs-keyword">if</span>(ufds.<span class="hljs-built_in">find</span>(s)!=ufds.<span class="hljs-built_in">find</span>(t)) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<span class="hljs-keyword">continue</span>; &#125;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">LCA</span>(s,t));
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;	
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></details><h1 id="p4281-ahoi2008紧急集合-聚会"><a class="markdownIt-Anchor" href="#p4281-ahoi2008紧急集合-聚会"></a> P4281 [AHOI2008]紧急集合 / 聚会</h1><h2 id="题意-3"><a class="markdownIt-Anchor" href="#题意-3"></a> 题意</h2><p>给定一棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个节点的树以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 次询问，每次询问给出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 三个节点，需要在树上找一个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dis(x,p)+dis(y,p)+dis(z,p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span> 取最小值（其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dis(a,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> 指 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">b</span></span></span></span> 两点的距离），每一次询问输出满足条件的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 和此时的最小值。</p><details><summary>点击查看题解</summary><h2 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h2><p>我们先钦定这棵树树根为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。然后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 点无非就三种情况：</p><ul><li>三点中两两 LCA 都相同：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 点就是这个 LCA 啦！</li><li>三点中有两对点 LCA 相同：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 点就是这个 LCA 啦！如果是另一对点的 LCA，就徒增了一段到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">p</span></span></span></span> 的距离。</li><li>三点中两两 LCA 互不相同：其实这种情况不存在。根据“仓鼠找sugar”一题的“感性的解释”，三个点就相当于有四个点，其中有一对点重合。而这样一定会有一对点的 LCA 在另一对点所形成的路径上。不妨设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的 LCA 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 的 LCA 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">b</span></span></span></span>，那么 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 的 LCA 以及 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 的 LCA 就相同了。</li></ul><p>这样，我们可以将情况 1 合并到情况 2 中，通过求每两个点的 LCA，计算出三个点距离 LCA 的距离和，这样计算并比较 3 次，可得出答案。</p><h2 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h2><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">500000</span>+<span class="hljs-number">10</span>,Log=<span class="hljs-number">20</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
	<span class="hljs-type">int</span> n,Root,Q,cnt=<span class="hljs-number">0</span>,d[N],head[N],f[Log+<span class="hljs-number">5</span>][N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;e[++cnt]=(edge)&#123;head[a],b&#125;;head[a]=cnt;&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[root];i;i=e[i].nxt)
		&#123;
			<span class="hljs-type">int</span> son=e[i].to;
			<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>][root]==son) <span class="hljs-keyword">continue</span>;
			d[son]=d[root]+<span class="hljs-number">1</span>;f[<span class="hljs-number">0</span>][son]=root;<span class="hljs-built_in">dfs</span>(son);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>
	</span>&#123;
		d[Root]=<span class="hljs-number">1</span>;<span class="hljs-built_in">dfs</span>(Root);f[<span class="hljs-number">0</span>][Root]=Root;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Log;i++)
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
				f[i][j]=f[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
		<span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Log;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-keyword">if</span>(d[f[i][x]]&gt;=d[y]) x=f[i][x];
		<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> x;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=Log;i&gt;=<span class="hljs-number">0</span>;i--)
			<span class="hljs-keyword">if</span>(f[i][x]!=f[i][y]) 
				x=f[i][x],y=f[i][y];
		<span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>][x];
	&#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
		<span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>,lca=<span class="hljs-built_in">LCA</span>(x,y);
		ret+=<span class="hljs-built_in">abs</span>(d[x]-d[lca]);
		ret+=<span class="hljs-built_in">abs</span>(d[y]-d[lca]);
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-type">int</span> tmp,t1,t2,t3,l12,l13,l23,pans,vans;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;Q);Root=<span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2),<span class="hljs-built_in">add</span>(t1,t2),<span class="hljs-built_in">add</span>(t2,t1);
		<span class="hljs-built_in">init</span>();
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=Q;i++)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);
			l12=<span class="hljs-built_in">LCA</span>(t1,t2),l13=<span class="hljs-built_in">LCA</span>(t1,t3),l23=<span class="hljs-built_in">LCA</span>(t2,t3);
			pans=l12,vans=<span class="hljs-built_in">dis</span>(t1,l12)+<span class="hljs-built_in">dis</span>(t2,l12)+<span class="hljs-built_in">dis</span>(t3,l12);
			tmp=<span class="hljs-built_in">dis</span>(t1,l13)+<span class="hljs-built_in">dis</span>(t2,l13)+<span class="hljs-built_in">dis</span>(t3,l13);
			<span class="hljs-keyword">if</span>(tmp&lt;vans) pans=l13,vans=tmp;
			tmp=<span class="hljs-built_in">dis</span>(t1,l23)+<span class="hljs-built_in">dis</span>(t2,l23)+<span class="hljs-built_in">dis</span>(t3,l23);
			<span class="hljs-keyword">if</span>(tmp&lt;vans) pans=l23,vans=tmp;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,pans,vans); 	
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

</code></pre></details><h1 id="p4180-bjwc2010严格次小生成树"><a class="markdownIt-Anchor" href="#p4180-bjwc2010严格次小生成树"></a> P4180 [BJWC2010]严格次小生成树</h1><h2 id="题意-4"><a class="markdownIt-Anchor" href="#题意-4"></a> 题意</h2><p>给定含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 条边的无向图，求其严格次小生成树。严格次小生成树定义为：如果最小生成树选择的边集是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">E_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，严格次小生成树选择的边集是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>S</mi></msub></mrow><annotation encoding="application/x-tex">E_S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.32833099999999993em"><span style="top:-2.5500000000000003em;margin-left:-.05764em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，那么需要满足：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mi>e</mi><mo>∈</mo><msub><mi>E</mi><mi>M</mi></msub></mrow></msub><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>&lt;</mo><msub><mo>∑</mo><mrow><mi>e</mi><mo>∈</mo><msub><mi>E</mi><mi>S</mi></msub></mrow></msub><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{e \in E_M}value(e)&lt;\sum_{e \in E_S}value(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.150015em;vertical-align:-.400015em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.17862099999999992em"><span style="top:-2.4002900000000005em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3448em"><span style="top:-2.3567071428571427em;margin-left:-.05764em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.14329285714285717em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.400015em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.150015em;vertical-align:-.400015em"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-.0000050000000000050004em">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.17862099999999992em"><span style="top:-2.4002900000000005em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">e</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3448em"><span style="top:-2.3567071428571427em;margin-left:-.05764em;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:.05764em">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.14329285714285717em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.400015em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">value(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> 表示边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">e</span></span></span></span> 的权值。</p><details><summary>点击查看题解</summary><h2 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h2><p>要求严格次小生成树，我们需先求最小生成树。求出来后，由于最小生成树上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的路径一定是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的最小瓶颈路之一（“最小瓶颈路”的概念已在<a href="/7fcca1bd3023">这篇文章</a>中介绍），所以未纳入的边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 的边权一定大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 最小瓶颈路的瓶颈。</p><p>因此，我们枚举每一个未纳入最小生成树的边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span>，断掉原先 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 路径上的瓶颈（若瓶颈和这条边权值相等，断其次大瓶颈，从而保证严格次小），再把此边加入这棵树（其实不用真的加边），这样就生成了一棵劣于最小生成树的生成树。更新答案即可。</p><p>由于可能要断次大瓶颈，所以不仅要像“货车运输”一题那样要建立倍增数组存最大值，还要再开一个存次大值。各种细节见代码。</p><h2 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h2><p><s>注意这个代码有恶臭味。</s></p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span>
	<span class="hljs-type">const</span> ll M=<span class="hljs-number">3000000</span>+<span class="hljs-number">10</span>,N=<span class="hljs-number">1000000</span>+<span class="hljs-number">10</span>,V=<span class="hljs-number">20</span>,Inf=<span class="hljs-number">1145141919810999999</span>;<span class="hljs-comment">//Inf 要开得足够大！</span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Road</span>&#123;ll u,v,len;&#125;road[M];
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll nxt,to,len;&#125;e[M*<span class="hljs-number">2</span>];
		ll head[N],cnt;
		<span class="hljs-built_in">Graph</span>()&#123;<span class="hljs-built_in">memset</span>(head,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(head));cnt=<span class="hljs-number">0</span>;&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b,ll c)</span></span>&#123;e[++cnt]=(edge)&#123;head[a],b,c&#125;;head[a]=cnt;&#125;
	&#125;Tree;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
	&#123;
		ll dad[M],n;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
		<span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span>
		</span>&#123;   
    		<span class="hljs-keyword">while</span>(x!=dad[x])
        		x=dad[x]=dad[dad[x]];
    		<span class="hljs-keyword">return</span> x;
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union_</span><span class="hljs-params">(ll x,ll y)</span>
		</span>&#123;
    		ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		dad[d1]=d2;
    		<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x,ll y)</span>
		</span>&#123;
    		ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		<span class="hljs-keyword">if</span>(d1==d2)
        		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
	&#125;ufds;
	ll n,m,f[V+<span class="hljs-number">5</span>][N],d[N],A[V+<span class="hljs-number">5</span>][N],B[V+<span class="hljs-number">5</span>][N];
	<span class="hljs-type">long</span> <span class="hljs-type">long</span> size=<span class="hljs-number">0</span>,ans=Inf;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Road a,Road b)</span></span>&#123; <span class="hljs-keyword">return</span> a.len&lt;b.len; &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span>
	</span>&#123;
    	ll num=<span class="hljs-number">0</span>,ru,rv; 
		ufds.<span class="hljs-built_in">init</span>(n);
    	<span class="hljs-built_in">sort</span>(road+<span class="hljs-number">1</span>,road+m+<span class="hljs-number">1</span>,cmp);
    	<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)
    	&#123;
       		ru=ufds.<span class="hljs-built_in">find</span>(road[i].u),rv=ufds.<span class="hljs-built_in">find</span>(road[i].v);
        	<span class="hljs-keyword">if</span>(ru==rv)
            	<span class="hljs-keyword">continue</span>;
			Tree.<span class="hljs-built_in">add</span>(road[i].u,road[i].v,road[i].len);
			Tree.<span class="hljs-built_in">add</span>(road[i].v,road[i].u,road[i].len);
			size+=road[i].len;<span class="hljs-comment">//求最小生成树</span>
			road[i].len=Inf;<span class="hljs-comment">//去除已纳入最小生成树的边</span>
			ufds.<span class="hljs-built_in">union_</span>(ru,rv);
        	<span class="hljs-keyword">if</span>(++num==n<span class="hljs-number">-1</span>)
            	<span class="hljs-keyword">break</span>;
    	&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll now)</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=Tree.head[now];i;i=Tree.e[i].nxt)
		&#123;
			ll to=Tree.e[i].to,len=Tree.e[i].len;
			<span class="hljs-keyword">if</span>(f[<span class="hljs-number">0</span>][now]!=to)
				d[to]=d[now]+<span class="hljs-number">1</span>,f[<span class="hljs-number">0</span>][to]=now,A[<span class="hljs-number">0</span>][to]=len,<span class="hljs-built_in">dfs</span>(to);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LCAinit</span><span class="hljs-params">()</span>
	</span>&#123;
		f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>,<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=V;i++)
			<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=n;j++)
			&#123;
				f[i][j]=f[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]];
				A[i][j]=<span class="hljs-built_in">max</span>(A[i<span class="hljs-number">-1</span>][j],A[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]]);<span class="hljs-comment">//最大值</span>
				B[i][j]=<span class="hljs-built_in">max</span>(B[i<span class="hljs-number">-1</span>][j],B[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]]);<span class="hljs-comment">//严格次大值</span>
				<span class="hljs-keyword">if</span>(A[i<span class="hljs-number">-1</span>][j]!=A[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]])<span class="hljs-comment">//注意！！！</span>
					<span class="hljs-comment">//如果两者相等还更新次大值，次大值就不严格了</span>
					B[i][j]=<span class="hljs-built_in">max</span>(B[i][j],<span class="hljs-built_in">min</span>(A[i<span class="hljs-number">-1</span>][j],A[i<span class="hljs-number">-1</span>][f[i<span class="hljs-number">-1</span>][j]]));
			&#125;
	&#125;
	<span class="hljs-function">ll <span class="hljs-title">LCA</span><span class="hljs-params">(ll x,ll y,ll C)</span>
	</span>&#123;
		ll ret=-Inf;
		<span class="hljs-keyword">if</span>(d[x]&lt;d[y]) <span class="hljs-built_in">swap</span>(x,y);
		<span class="hljs-keyword">for</span>(ll i=V;i&gt;=<span class="hljs-number">0</span>;i--) 
			<span class="hljs-keyword">if</span>(d[f[i][x]]&gt;=d[y]) 
			&#123;
				<span class="hljs-keyword">if</span>(A[i][x]&lt;C) ret=<span class="hljs-built_in">max</span>(ret,A[i][x]);<span class="hljs-comment">//如果断边边权大于等于加入的边</span>
				<span class="hljs-keyword">else</span> ret=<span class="hljs-built_in">max</span>(ret,B[i][x]);<span class="hljs-comment">//就不是严格次小了，所以用次大边更新</span>
				x=f[i][x];
			&#125;	
		<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> ret;
		<span class="hljs-keyword">for</span>(ll i=V;i&gt;=<span class="hljs-number">0</span>;i--)
			<span class="hljs-keyword">if</span>(f[i][x]!=f[i][y]) 
			&#123;
				<span class="hljs-keyword">if</span>(A[i][x]&lt;C) ret=<span class="hljs-built_in">max</span>(ret,A[i][x]);
				<span class="hljs-keyword">else</span> ret=<span class="hljs-built_in">max</span>(ret,B[i][x]);
				<span class="hljs-keyword">if</span>(A[i][y]&lt;C) ret=<span class="hljs-built_in">max</span>(ret,A[i][y]);
				<span class="hljs-keyword">else</span> ret=<span class="hljs-built_in">max</span>(ret,B[i][y]);
				x=f[i][x],y=f[i][y];
			&#125;
		<span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>][x]&lt;C) ret=<span class="hljs-built_in">max</span>(ret,A[<span class="hljs-number">0</span>][x]);
		<span class="hljs-keyword">else</span> ret=<span class="hljs-built_in">max</span>(ret,B[<span class="hljs-number">0</span>][x]);
		<span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>][y]&lt;C) ret=<span class="hljs-built_in">max</span>(ret,A[<span class="hljs-number">0</span>][y]);
		<span class="hljs-keyword">else</span> ret=<span class="hljs-built_in">max</span>(ret,B[<span class="hljs-number">0</span>][y]);
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		ll ta,tb,tc;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;ta,&amp;tb,&amp;tc),
			road[i]=(Road)&#123;ta,tb,tc&#125;;
		<span class="hljs-built_in">kruskal</span>();<span class="hljs-built_in">LCAinit</span>();<span class="hljs-comment">//先构建最小生成树</span>
		<span class="hljs-built_in">sort</span>(road+<span class="hljs-number">1</span>,road+<span class="hljs-number">1</span>+m,cmp);
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)
		&#123;
			ll len=road[i].len; <span class="hljs-keyword">if</span>(len==Inf) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//枚举完边就退出</span>
			ll u=road[i].u,v=road[i].v;
			ans=<span class="hljs-built_in">min</span>(ans,size-<span class="hljs-built_in">LCA</span>(u,v,len)+len);<span class="hljs-comment">//次小生成树=最小生成树-瓶颈+新边</span>
		&#125;
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);
		<span class="hljs-keyword">return</span>;
	&#125;	
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></details><br><hr><br><blockquote><br>本文作者：Yurchiu<br><br>本文链接：https://yz-hs.github.io/47cfbdb04aea/<br><br>版权声明：本博客中所有原创文章除特别声明外，均允许规范转载，转载请注明出处。所有非原创文章，按照原作者要求转载。<br><br></blockquote><br><div class="end-post-meta"><span><a href="/tags/OI"><i class="fa fa-tag"></i> OI</a></span> <span><a href="/tags/倍增"><i class="fa fa-tag"></i> 倍增</a></span> <span><a href="/tags/树"><i class="fa fa-tag"></i> 树</a></span> <span><a href="/tags/最小生成树"><i class="fa fa-tag"></i> 最小生成树</a></span> <span><a href="/tags/LCA"><i class="fa fa-tag"></i> LCA</a></span> <span><a href="/tags/一些"><i class="fa fa-tag"></i> 一些</a></span></div><div class="end-post-meta"><span><i class="fa fa-refresh"></i> 最后更新：2023-08-18, 13:53:06</span></div></div><div class="prevnext"><a class="prev" href="/224a610e0b0b/">上一页</a> <a class="next" href="/725d61041676/">下一页</a></div><div class="comments"><div class="giscus"></div><script>function my_giscus_load(){var t=document.createElement("script");t.setAttribute("src","https://giscus.app/client.js"),t.setAttribute("data-repo","yz-hs/no-star"),t.setAttribute("data-repo-id","R_kgDOKHnuhg"),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOKHnuhs4CYog9"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-strict","0"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-emit-metadata","0"),t.setAttribute("data-input-position","top"),t.setAttribute("data-theme","light"),4==readData("color")&&t.setAttribute("data-theme","dark"),t.setAttribute("data-lang","zh-CN"),t.setAttribute("data-loading","lazy"),t.setAttribute("crossorigin","anonymous"),t.setAttribute("async","true"),document.head.appendChild(t)}my_giscus_load()</script></div><div class="avatar-container" style="padding:50px"><img src="/img/new-avatar.jpg" class="avatar revolve" style="height:12%;width:12%"><div style="text-align:center;margin-top:3%">By Yurchiu.</div></div></div><div class="vertical toolbar"><div class="tab-page"><div class="tabTitle tb-tabTitle"><ul><li class="current"><i class="fa fa-random"></i></li><li><i class="fa fa-refresh"></i></li><li><i class="fa fa-circle-o-notch"></i></li></ul></div><div class="tabContent tb-tabContent"><div><div class="title">随机文章<span class="sidetitle">回味旧文</span></div><div class="item no-lrpadding"><a class="post-link" href="/3513c6ef3e31/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2021，初中毕业</div></div></a><a class="post-link" href="/d24d99489782/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2020 新年贺词</div></div></a><a class="post-link" href="/3f5d366e12dd/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">一个 4 人囚徒困境的必胜策略</div></div></a><a class="post-link" href="/501647d25831/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">AFO 有感</div></div></a><a class="post-link" href="/ed885af1fef5/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">ASCII 艺术</div></div></a><a class="post-link" href="/2ab979d324b5/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">BSGS 与 exBSGS</div></div></a><a class="post-link" href="/1ed002c31ce3/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">CSP-J1 游记</div></div></a></div></div><div class="hide"><div class="title">最近更新<span class="sidetitle">旧文更新</span></div><div class="item no-lrpadding"><a class="post-link" href="/4d8f0cef397c/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">【解析几何】仿射变换</div></div></a><a class="post-link" href="/2565dbc61d2c/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">NOIP-2021 有感</div></div></a><a class="post-link" href="/0d102f9a3ef1/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">OI 之旅</div></div></a><a class="post-link" href="/f4829e127292/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">小技巧和一些代码</div></div></a><a class="post-link" href="/a8a50914f320/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">yaml 多行字符串</div></div></a><a class="post-link" href="/b12321c1b85e/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">SweetAlert 的使用</div></div></a><a class="post-link" href="/6c70d3b4b7b8/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">PicGo 使用</div></div></a></div></div><div class="hide"><div class="title">其他物件<a data-bs-toggle="tooltip" href="javascript: document.body.contentEditable='true';
    document.designMode='on';void(0);" title="彩蛋：点击我，可以编辑本页面！" target="_self" class="sidetitle">杂物收纳</a></div><div style="height:10px"></div><div class="item"><tag style="display:inline-block">Hitokoto</tag><br><br><div id="hitokoto">Yurchiu 说，除了她以外的人都很强！嘤嘤嘤~~</div><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){$("#hitokoto").html(t.hitokoto+"<br><br><div style='text-align: right;'>——"+t.from+"</div>")}).catch(function(t){console.error(t)})</script></div><div class="item"><div id="timeprogress"></div><script>var myDate=new Date,hours=myDate.getHours(),minutes=myDate.getMinutes(),pro=(minutes=60*hours+minutes)/14.4,innerhtml="        <div class='progress' style='height: 20px'>          <div data-bs-toggle='tooltip'               class='progress-bar'               title='时间已过去了 "+pro.toFixed(2)+"%'               style='width: "+pro+"%;               background: #4caf50; color: #fff;'>"+pro.toFixed(0)+"%          </div>        </div>";document.getElementById("timeprogress").innerHTML=innerhtml</script></div></div></div></div><div class="item"><div class="title">博客信息</div><div class="list-group"><div class="list-group-item"><div><i class="fa fa-file-text-o fa-fw"></i> 文章数目</div><div class="badge">159</div></div><div class="list-group-item"><div><i class="fa fa-refresh fa-fw"></i> 最近更新</div><div class="badge">08-18</div></div><div class="list-group-item"><div><i class="fa fa-font fa-fw"></i> 本站字数</div><div class="badge">340.1k</div></div></div></div><div class="post-toc"><div class="title">文章目录</div><div class="post-toc-inner"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#p3398-%E4%BB%93%E9%BC%A0%E6%89%BEsugar"><span class="toc-text">P3398 仓鼠找sugar</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#p1967-noip2013-%E6%8F%90%E9%AB%98%E7%BB%84-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93"><span class="toc-text">P1967 [NOIP2013 提高组] 货车运输</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#p4281-ahoi2008%E7%B4%A7%E6%80%A5%E9%9B%86%E5%90%88-%E8%81%9A%E4%BC%9A"><span class="toc-text">P4281 [AHOI2008]紧急集合 &#x2F; 聚会</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#p4180-bjwc2010%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">P4180 [BJWC2010]严格次小生成树</span></a></li></ol></div></div><script>$(function(){var i=$(".tb-tabTitle>ul>li"),n=$(".tb-tabContent>div");i.click(function(){var t=$(this);setTimeout(function(){t.addClass("current").siblings().removeClass("current");var i=t.index();n.eq(i).show().siblings().hide()})})})</script></div></div><div class="footer"><p class="text-left">©2019-2023 <a target="_blank" rel="noopener" href="https://github.com/yz-hs">Yurchiu</a>. All rights reserved.</p><p class="text-right">Theme <a target="_blank" rel="noopener" href="https://github.com/yz-hs/cutie">Cutie</a>, by Yurchiu.</p></div><div class="natsuki-container" style="width:120px" data-bs-toggle="tooltip" title="Don't touch me! qwq"><img id="natsuki2" width="100%" height="100%" src="/img/natsuki2.png"> <img id="natsuki1" width="100%" height="100%" src="/img/natsuki1.png"></div><script type="text/javascript">$("#natsuki1").click(function(){$("#natsuki1").hide(),$("#natsuki2").show(),$("#natsuki2").css("animation","natsuki 0.55s cubic-bezier(0, 0, 0, 1)")}),$("#natsuki2").each(function(){$(this)[0].addEventListener("animationend",function(){$("#natsuki2").hide(),$("#natsuki1").show(),$(this).css("animation","")})})</script><script>readData("special")||$("html").addClass("none")</script><script>readData("color")||$("html").addClass("color-white"),4==readData("color")&&($("body").css("opacity","0.8"),$("body").css("background-image","url(/img/night-bgp.jpg)")),$("img").attr("onerror","this.src='/img/error.jpg';this.onerror=null"),initialization()</script></div><meting-js class="meting-js appear" fixed="ture" server="netease" type="playlist" id="8524070964"></meting-js><script>consolePrint(),HideIt()</script><style type="text/css">.effect{position:fixed;left:0;top:0;z-index:99999;pointer-events:none}</style><script src="/js/ctitle.js"></script><div id="clickCanvas" class="effect"></div><script src="/js/clickple.js"></script></body></html>