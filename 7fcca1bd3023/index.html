<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="msvalidate.01" content="A7B4DB5A7BF5E5C6E52E34BB024D6319"><meta name="description" content="本站为 Yurchiu 用来记录 OI、笔记、感想的 Blog，欢迎来到本博客！希望我们能相互交流，共同进步～"><meta http-equiv="content-language" content="zh-cn"><title>最小生成树 | Yurchiu's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/limonte-sweetalert2/11.4.17/sweetalert2.all.min.js"></script><script src="https://cdn.staticfile.org/sketch.js/1.0/sketch.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/chaffle.js"></script><script src="/js/main.js"></script><script src="/js/search.js"></script><script src="/js/initial.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/katex.min.css"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs2015.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"><link rel="stylesheet" href="/css/style.css"><link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Yurchiu's Blog" type="application/atom+xml"></head><body style="background-image:url(/img/new-bgp.png)"><div id="YurLoading" class="YurLoading"><div class="inner"><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div></div></div><div class="topbar"><a onclick="topbarToggle()" class="topbar-menu" style="cursor:pointer"><i class="fa fa-bars"></i> </a><a href="/" class="topbar-title"><i class="fa fa-home"></i> Yurchiu's Blog </a><a target="_blank" rel="noopener" href="https://github.com/yz-hs" class="topbar-title"><i class="fa fa-github"></i></a></div><div id="article-container"><div class="sidebar"><div class="avatar-container"><img src="/img/new-avatar.jpg" class="avatar revolve"></div><div class="sidebar-author">Yurchiu<br><span class="mini-text">An AFO whker.</span></div><div class="sidebar-list-container"><div style="height:10px"></div><a class="list-group-item" href="/"><div><i class="fa fa-home fa-fw"></i>&nbsp; 首页</div><div class="badge"></div></a><a class="list-group-item" href="/archives/"><div><i class="fa fa-tasks fa-fw"></i>&nbsp; 归档</div><div class="badge">160</div></a><a class="list-group-item" href="/tags/"><div><i class="fa fa-tags fa-fw"></i>&nbsp; 标签</div><div class="badge">81</div></a><a class="list-group-item" href="/categories/"><div><i class="fa fa-th-large fa-fw"></i>&nbsp; 分类</div><div class="badge">24</div></a><a class="list-group-item" href="/somepage/mood/"><div><i class="fa fa-photo fa-fw"></i>&nbsp; 说说</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/about/"><div><i class="fa fa-user-o fa-fw"></i>&nbsp; 关于</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/chat/"><div><i class="fa fa-commenting-o fa-fw"></i>&nbsp; 留言</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/link/"><div><i class="fa fa-link fa-fw"></i>&nbsp; 链接</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/settings/"><div><i class="fa fa-cog fa-fw"></i>&nbsp; 设置</div><div class="badge"></div></a><div style="height:200px"></div></div><div class="sidebar-footer"><div class="item" id="back2Top" data-bs-toggle="tooltip" title="顶部"><i class="fa fa-arrow-circle-up"></i></div><div class="item" id="back2Down" data-bs-toggle="tooltip" title="底部"><i class="fa fa-arrow-circle-down"></i></div><div class="item" data-bs-toggle="tooltip" title="RSS"><a href="/atom.xml"><i class="fa fa-feed"></i></a></div><div class="item" data-bs-toggle="tooltip" title="搜索"><a href="/somepage/search/"><i class="fa fa-search"></i></a></div></div></div><div class="article"><div class="vertical fake-sidebar"></div><div class="vertical post"><div class="header"><h1 class="title">最小生成树</h1><div class="meta"><span><i class="fa fa-user-o"></i> Yurchiu </span><span><i class="fa fa-clock-o"></i> 2020-12-04, 10:28:25</span> <span><i class="fa fa-font"></i> 2.6k</span> <span class="hideBars" onclick="hideBars()"><i class="fa fa-eye-slash"></i> 隐藏左右两栏 </span><span class="showBars" onclick="showBars()"><i class="fa fa-eye"></i> 展示左右两栏</span></div></div><div class="breadcrumb"><div class="url"><a href="/"><i class="fa fa-home"></i> 首页</a> / 最小生成树</div><div class="share">分享到 <a target="_blank" rel="noopener" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yz-hs.github.io/7fcca1bd3023/&title=最小生成树&site=https://yz-hs.github.io"><i class="fa fa-qq"></i></a></div></div><div class="post-text"><p>本文为 Yurchiu 学习最小生成树的笔记以及模板。</p><p>最小生成树（MST）其实是最小权重生成树的简称。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点的连通块，边有权，保留 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 条边，图仍连通，且边权和最小所形成的树即为最小生成树。最小生成树的“方案”并不是唯一的。</p><h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1><p>规定：n 点数，m 边数。</p><h2 id="prim"><a class="markdownIt-Anchor" href="#prim"></a> Prim</h2><p>Prim 算法是一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。</p><h3 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h3><p>具体来说，每次要选择距离当前已加入的点集最小的一个结点，以及用新的边更新其他结点的距离。</p><pre class="highlight"><code>[1] [2]                         [8]
 [3] [4] [5]            [7]
   [6]                   ^                  [9]
   
已加入的点集               已加入的点集之外

^所指为距离当前已加入的点集最小的一个结点。
</code></pre><p>其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。</p><p>堆优化的方式类似 Dijkstra 的堆优化。</p><p>在稠密图尤其是完全图上，一般选择暴力 Prim 算法，时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，复杂度比 Kruskal 优，但 <strong>不一定</strong> 实际跑得更快。</p><h3 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h3><pre class="highlight"><code class="cpp"><span class="hljs-type">int</span> g[N][N],v[N],d[N];<span class="hljs-comment">//边，访问标记，距离当前已加入的点集的距离</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) d[i]=g[<span class="hljs-number">1</span>][i];v[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
    &#123;
    	<span class="hljs-type">int</span> to=<span class="hljs-number">-114514</span>,mn=inf;
 		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            <span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&lt;mn) to=j,mn=d[j];
        <span class="hljs-keyword">if</span>(to&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        ans+=mn,v[to]=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            <span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&gt;g[to][j])
                d[j]=g[to][j];
    &#125;
    <span class="hljs-keyword">return</span>;
&#125;
</code></pre><h2 id="kruskal"><a class="markdownIt-Anchor" href="#kruskal"></a> Kruskal</h2><p>Kruskal 算法是一种常见并且好写的最小生成树算法。</p><h3 id="实现-2"><a class="markdownIt-Anchor" href="#实现-2"></a> 实现</h3><p>该算法的基本思想是从小到大加入边，是个贪心算法。</p><p>使用并查集维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。</p><p>如果使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的排序算法，并且使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>α</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\alpha(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> 的并查集，就可以得到时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m log m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 的 Kruskal 算法。</p><p><strong>贪心的正确性</strong>（比较感性的证明）：</p><p>假设图中边权最小的边没被纳入最小生成树，则在生成完毕后，若加入这条边，必定会成为一个基环树。我们发现，删掉环上的其他一边，这个树仍是连通图中所有点的树，而这样必定比以前的生成树要优。</p><p>所以最小生成树一定包含一条图中边权最小的边。若纳入这条边，则可以产生一个新的连通块，则这个连通块可作为一个点再参与最小生成树的生成。</p><p>注：同理，如果把边集合按边权从大到小枚举，可以得到一个<strong>最大生成树</strong>。</p><h3 id="模板-2"><a class="markdownIt-Anchor" href="#模板-2"></a> 模板</h3><pre class="highlight"><code class="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> u,v,len;&#125;e[M*<span class="hljs-number">2</span>];
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
&#123;
	<span class="hljs-type">int</span> dad[M],n;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
	</span>&#123;  
    	<span class="hljs-type">int</span> root=x;  
    	<span class="hljs-keyword">while</span>(root!=dad[root])
        	root=dad[root];
    	<span class="hljs-keyword">return</span> root;  
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union_</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
    	<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    	dad[d1]=d2;
    	<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
	</span>&#123;
    	<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    	<span class="hljs-keyword">if</span>(d1==d2)
        	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
&#125;ufds;<span class="hljs-comment">//并查集，无需解释</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge a,edge b)</span></span>&#123; <span class="hljs-keyword">return</span> a.len&lt;b.len; &#125;
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>,ru,rv; 
    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+cnt+<span class="hljs-number">1</span>,cmp);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
    &#123;
       	ru=ufds.<span class="hljs-built_in">find</span>(e[i].u),rv=ufds.<span class="hljs-built_in">find</span>(e[i].v);
        <span class="hljs-keyword">if</span>(ru==rv)
           	<span class="hljs-keyword">continue</span>;
       	ans+=e[i].len;
		ufds.<span class="hljs-built_in">union_</span>(ru,rv);
       	<span class="hljs-keyword">if</span>(++num==n<span class="hljs-number">-1</span>)
           	<span class="hljs-keyword">break</span>;
    &#125;
&#125;
</code></pre><h1 id="最小瓶颈生成树"><a class="markdownIt-Anchor" href="#最小瓶颈生成树"></a> 最小瓶颈生成树</h1><p>即对于图 G 中的生成树上最大的边权值在所有生成树中最小。无向图中，定义上，最小生成树是它的子集。</p><p>使用 Kruskal 算法在 G 上构造一个最小生成树，选取的最大边权为 e，我们发现无法使用边权小于 e 的边构造一棵树，因为我们舍弃的边对于构造树来讲是重复的，冗余的。</p><p>所以，最小生成树是最小瓶颈生成树。</p><h1 id="最小瓶颈路"><a class="markdownIt-Anchor" href="#最小瓶颈路"></a> 最小瓶颈路</h1><p>最小瓶颈路问题是指在一张无向图中，询问一个点对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span>，需要找出从 u 到 v 的一条简单路径，使路径上所有边中边权最大值最小。</p><p>无向图最小生成树上 u 到 v 的路径一定是 u 到 v 的最小瓶颈路之一。同理也可得到：最大生成树上的路径是最小边权最大路径之一。</p><p>使用 Kruskal 算法构造最小生成树，若边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 边权为 e，被丢弃，原因是可以使用小于 e 的边构造出一条从 u 到 v 的路径。若边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mclose">)</span></span></span></span> 被纳入最小生成树，则意味着，不能使用小于 e 的边构造一条从 u 到 v 的路径。e 实际上就是从 u 到 v 路径的瓶颈。</p><p>所以，最小生成树上 u 到 v 的路径一定是 u 到 v 的最小瓶颈路之一。</p><h1 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h1><h2 id="p3366-模板最小生成树"><a class="markdownIt-Anchor" href="#p3366-模板最小生成树"></a> P3366 【模板】最小生成树</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">link</a>。~~这玩意是模板，怎么能是例题呢？~~所以，直接抛代码：</p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-type">const</span> <span class="hljs-type">int</span> M=<span class="hljs-number">200000</span>+<span class="hljs-number">10</span>,N=<span class="hljs-number">5000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> u,v,len;&#125;e[M*<span class="hljs-number">2</span>];
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
	&#123;
		<span class="hljs-type">int</span> dad[M],n;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
		<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
		</span>&#123;  
    		<span class="hljs-type">int</span> root=x;  
    		<span class="hljs-keyword">while</span>(root!=dad[root])
        		root=dad[root];
    		<span class="hljs-keyword">return</span> root;  
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">union_</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
		</span>&#123;
    		<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		dad[d1]=d2;
    		<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>
		</span>&#123;
    		<span class="hljs-type">int</span> d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
    		<span class="hljs-keyword">if</span>(d1==d2)
        		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
		&#125;
	&#125;ufds;
	<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>,n,m,ans=<span class="hljs-number">0</span>;
	<span class="hljs-type">int</span> g[N][N],v[N],d[N];
	<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> x)</span>
	</span>&#123;
		e[++cnt]=(edge)&#123;a,b,x&#125;;
		g[a][b]=<span class="hljs-built_in">min</span>(x,g[a][b]);
	&#125;
	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge a,edge b)</span></span>&#123; <span class="hljs-keyword">return</span> a.len&lt;b.len; &#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span>
	</span>&#123;
    	<span class="hljs-type">int</span> num=<span class="hljs-number">0</span>,ru,rv; 
    	<span class="hljs-built_in">sort</span>(e,e+cnt,cmp);
    	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
    	&#123;
       		ru=ufds.<span class="hljs-built_in">find</span>(e[i].u),rv=ufds.<span class="hljs-built_in">find</span>(e[i].v);
        	<span class="hljs-keyword">if</span>(ru==rv)
            	<span class="hljs-keyword">continue</span>;
        	ans+=e[i].len;
			ufds.<span class="hljs-built_in">union_</span>(ru,rv);
        	<span class="hljs-keyword">if</span>(++num==n<span class="hljs-number">-1</span>)
            	<span class="hljs-keyword">break</span>;
    	&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span>
	</span>&#123;
	    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) d[i]=g[<span class="hljs-number">1</span>][i];v[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
	    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
    	&#123;
    		<span class="hljs-type">int</span> to=<span class="hljs-number">-114514</span>,mn=inf;
 		    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            	<span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&lt;mn) to=j,mn=d[j];
            <span class="hljs-keyword">if</span>(to&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        	ans+=mn,v[to]=<span class="hljs-number">1</span>;
        	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            	<span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&gt;g[to][j])
                	d[j]=g[to][j];
    	&#125;
    	<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-type">int</span> t1,t2,t3;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);
		ufds.<span class="hljs-built_in">init</span>(n);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
				<span class="hljs-keyword">if</span>(i==j) g[i][j]=<span class="hljs-number">0</span>;
				<span class="hljs-keyword">else</span> g[i][j]=inf;
		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);
			<span class="hljs-built_in">add</span>(t1,t2,t3);
			<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">add</span>(t2,t1,t3);
		&#125;
		<span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>) <span class="hljs-built_in">prim</span>();
		<span class="hljs-keyword">else</span> <span class="hljs-built_in">kruskal</span>();
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre><h2 id="p1265-公路修建"><a class="markdownIt-Anchor" href="#p1265-公路修建"></a> P1265 公路修建</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1265">link</a>。</p><h3 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h3><p>某国有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个城市，它们互相之间没有公路相通。政府决定修建公路。</p><p>修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。</p><p>政府审批的规则如下：</p><ul><li><p>如果两个或以上城市申请修建同一条公路，则让它们共同修建；</p></li><li><p>如果三个或以上的城市申请修建的公路成环，例如，若 A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA，则政府将否决其中最短的一条公路的修建申请；</p></li><li><p>其他情况的申请一律同意。</p></li></ul><p>一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。</p><p>当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。你的任务是计算出将要修建的公路总长度。</p><h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3><p>首先可以证明，规则 2 是毫无用处的，因为三个以上城市成环的情况是不可能出现的。满足题意的话，A B C 只能组成正三角形。</p><p>接下来可以证明，按“轮”进行处理也是没有必要的。</p><p>因此只需直接求出最小生成树即可。</p><p>Prim 算法的优势：稠密图，尤其是完全图。因为在 Kruskal 算法中，必须事先求出所有边的长度才能对之排序。但是一个有 5000 节点的完全图，这样做的空间、时间开销是巨大的。Prim 算法只在更新点到树的距离时需要用到边长，因此对于这种给坐标的完全图，可以现用现算。</p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> _yz
&#123;
	<span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> N=<span class="hljs-number">5000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pos</span>&#123;<span class="hljs-type">long</span> <span class="hljs-type">long</span> x,y;&#125;c[N];
	<span class="hljs-type">long</span> <span class="hljs-type">long</span> v[N],n; <span class="hljs-type">double</span> d[N],ans=<span class="hljs-number">0</span>;
	
	<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((c[a].x-c[b].x)*(c[a].x-c[b].x)+(c[a].y-c[b].y)*(c[a].y-c[b].y));&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span>
	</span>&#123;
    	<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) d[i]=<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>,i);v[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;
    	<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
    	&#123;
        	<span class="hljs-type">long</span> <span class="hljs-type">long</span> to=<span class="hljs-number">-114514</span>;
			<span class="hljs-type">double</span> mn=inf;
         	<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            	<span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&lt;mn) to=j,mn=d[j];
        	<span class="hljs-keyword">if</span>(to&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        	ans+=mn,v[to]=<span class="hljs-number">1</span>;
        	<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)
            	<span class="hljs-keyword">if</span>(!v[j]&amp;&amp;d[j]&gt;<span class="hljs-built_in">g</span>(to,j))
                	d[j]=<span class="hljs-built_in">g</span>(to,j);
    	&#125;
    	<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yzmain</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
		<span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;c[i].x,&amp;c[i].y);
		<span class="hljs-built_in">prim</span>();
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>,ans);
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	<span class="hljs-comment">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span>
	<span class="hljs-comment">//freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);</span>
	_yz::<span class="hljs-built_in">yzmain</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre><p>其他题解见 <a href="/0cd5e6b46a46">2</a>。</p><br><hr><br><blockquote><br>本文作者：Yurchiu<br><br>本文链接：https://yz-hs.github.io/7fcca1bd3023/<br><br>版权声明：本博客中所有原创文章除特别声明外，均允许规范转载，转载请注明出处。所有非原创文章，按照原作者要求转载。<br><br></blockquote><br><div class="end-post-meta"><span><a href="/tags/OI"><i class="fa fa-tag"></i> OI</a></span> <span><a href="/tags/图论"><i class="fa fa-tag"></i> 图论</a></span> <span><a href="/tags/最小生成树"><i class="fa fa-tag"></i> 最小生成树</a></span></div><div class="end-post-meta"><span><i class="fa fa-refresh"></i> 最后更新：2023-08-06, 17:08:55</span></div></div><div class="prevnext"><a class="prev" href="/32b6c27e7d4b/">上一页</a> <a class="next" href="/1a6156b5845c/">下一页</a></div><div class="comments"><div class="giscus"></div><script>function my_giscus_load(){var t=document.createElement("script");t.setAttribute("src","https://giscus.app/client.js"),t.setAttribute("data-repo","yz-hs/no-star"),t.setAttribute("data-repo-id","R_kgDOKHnuhg"),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOKHnuhs4CYog9"),t.setAttribute("data-mapping","pathname"),t.setAttribute("data-strict","0"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-emit-metadata","0"),t.setAttribute("data-input-position","top"),t.setAttribute("data-theme","light"),4==readData("color")&&t.setAttribute("data-theme","dark"),t.setAttribute("data-lang","zh-CN"),t.setAttribute("data-loading","lazy"),t.setAttribute("crossorigin","anonymous"),t.setAttribute("async","true"),document.head.appendChild(t)}my_giscus_load()</script></div><div class="avatar-container" style="padding:50px"><img src="/img/new-avatar.jpg" class="avatar revolve" style="height:12%;width:12%"><div style="text-align:center;margin-top:3%">By Yurchiu.</div></div></div><div class="vertical toolbar"><div class="tab-page"><div class="tabTitle tb-tabTitle"><ul><li class="current"><i class="fa fa-random"></i></li><li><i class="fa fa-refresh"></i></li><li><i class="fa fa-circle-o-notch"></i></li></ul></div><div class="tabContent tb-tabContent"><div><div class="title">随机文章<span class="sidetitle">回味旧文</span></div><div class="item no-lrpadding"><a class="post-link" href="/d24d99489782/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2020 新年贺词</div></div></a><a class="post-link" href="/3f5d366e12dd/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">一个 4 人囚徒困境的必胜策略</div></div></a><a class="post-link" href="/501647d25831/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">AFO 有感</div></div></a><a class="post-link" href="/3513c6ef3e31/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2021，初中毕业</div></div></a><a class="post-link" href="/ed885af1fef5/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">ASCII 艺术</div></div></a><a class="post-link" href="/2ab979d324b5/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">BSGS 与 exBSGS</div></div></a><a class="post-link" href="/1ed002c31ce3/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">CSP-J1 游记</div></div></a></div></div><div class="hide"><div class="title">最近更新<span class="sidetitle">旧文更新</span></div><div class="item no-lrpadding"><a class="post-link" href="/4c42185773d2/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">[Works] Climbing</div></div></a><a class="post-link" href="/51eaeba01a9b/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">[Works] Shelter(adapted)</div></div></a><a class="post-link" href="/7a042de58116/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">《幽默报 2》</div></div></a><a class="post-link" href="/39e4c172e542/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">Cutie 使用文档</div></div></a><a class="post-link" href="/8e539c22a86e/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">Matrix 例题</div></div></a><a class="post-link" href="/3c7dcf6a11e0/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">NOI Linux</div></div></a><a class="post-link" href="/c9317a28769e/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">Tarjan 算法</div></div></a></div></div><div class="hide"><div class="title">其他物件<a data-bs-toggle="tooltip" href="javascript: document.body.contentEditable='true';
    document.designMode='on';void(0);" title="彩蛋：点击我，可以编辑本页面！" target="_self" class="sidetitle">杂物收纳</a></div><div style="height:10px"></div><div class="item"><tag style="display:inline-block">Hitokoto</tag><br><br><div id="hitokoto">Yurchiu 说，除了她以外的人都很强！嘤嘤嘤~~</div><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){$("#hitokoto").html(t.hitokoto+"<br><br><div style='text-align: right;'>——"+t.from+"</div>")}).catch(function(t){console.error(t)})</script></div><div class="item"><div id="timeprogress"></div><script>var myDate=new Date,hours=myDate.getHours(),minutes=myDate.getMinutes(),pro=(minutes=60*hours+minutes)/14.4,innerhtml="        <div class='progress' style='height: 20px'>          <div data-bs-toggle='tooltip'               class='progress-bar'               title='时间已过去了 "+pro.toFixed(2)+"%'               style='width: "+pro+"%;               background: #4caf50; color: #fff;'>"+pro.toFixed(0)+"%          </div>        </div>";document.getElementById("timeprogress").innerHTML=innerhtml</script></div></div></div></div><div class="item"><div class="title">博客信息</div><div class="list-group"><div class="list-group-item"><div><i class="fa fa-file-text-o fa-fw"></i> 文章数目</div><div class="badge">160</div></div><div class="list-group-item"><div><i class="fa fa-refresh fa-fw"></i> 最近更新</div><div class="badge">08-06</div></div><div class="list-group-item"><div><i class="fa fa-font fa-fw"></i> 本站字数</div><div class="badge">341.8k</div></div></div></div><div class="post-toc"><div class="title">文章目录</div><div class="post-toc-inner"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#prim"><span class="toc-text">Prim</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kruskal"><span class="toc-text">Kruskal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-2"><span class="toc-text">模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">最小瓶颈生成树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%93%B6%E9%A2%88%E8%B7%AF"><span class="toc-text">最小瓶颈路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#p3366-%E6%A8%A1%E6%9D%BF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">P3366 【模板】最小生成树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#p1265-%E5%85%AC%E8%B7%AF%E4%BF%AE%E5%BB%BA"><span class="toc-text">P1265 公路修建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F"><span class="toc-text">题意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-text">题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div><script>$(function(){var i=$(".tb-tabTitle>ul>li"),n=$(".tb-tabContent>div");i.click(function(){var t=$(this);setTimeout(function(){t.addClass("current").siblings().removeClass("current");var i=t.index();n.eq(i).show().siblings().hide()})})})</script></div></div><div class="footer"><p class="text-left">©2019-2023 <a target="_blank" rel="noopener" href="https://github.com/yz-hs">Yurchiu</a>. All rights reserved.</p><p class="text-right">Theme <a target="_blank" rel="noopener" href="https://github.com/yz-hs/cutie">Cutie</a>, by Yurchiu.</p></div><div class="natsuki-container" style="width:120px" data-bs-toggle="tooltip" title="Don't touch me! qwq"><img id="natsuki2" width="100%" height="100%" src="/img/natsuki2.png"> <img id="natsuki1" width="100%" height="100%" src="/img/natsuki1.png"></div><script type="text/javascript">$("#natsuki1").click(function(){$("#natsuki1").hide(),$("#natsuki2").show(),$("#natsuki2").css("animation","natsuki 0.55s cubic-bezier(0, 0, 0, 1)")}),$("#natsuki2").each(function(){$(this)[0].addEventListener("animationend",function(){$("#natsuki2").hide(),$("#natsuki1").show(),$(this).css("animation","")})})</script><script>readData("special")||$("html").addClass("none")</script><script>readData("color")||$("html").addClass("color-white"),4==readData("color")&&($("body").css("opacity","0.85"),$("body").css("background-image","url(/img/night-bgp.jpg)")),$("img").attr("onerror","this.src='/img/error.jpg';this.onerror=null"),initial()</script></div><meting-js class="meting-js appear" fixed="ture" server="netease" type="playlist" id="8524070964"></meting-js><script>consolePrint(),HideIt()</script><link rel="stylesheet" href="/custom/custom.css"><script src="/custom/custom.js"></script></body></html>