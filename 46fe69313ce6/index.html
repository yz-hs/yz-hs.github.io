<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="msvalidate.01" content="A7B4DB5A7BF5E5C6E52E34BB024D6319"><meta name="description" content="本站为 Yurchiu 用来记录 OI、笔记、感想的 Blog，欢迎来到本博客！希望我们能相互交流，共同进步～"><meta http-equiv="content-language" content="zh-cn"><title>P5659 [CSP-S2019] 树上的数 | Yurchiu's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/limonte-sweetalert2/11.4.17/sweetalert2.all.min.js"></script><script src="https://cdn.staticfile.org/sketch.js/1.0/sketch.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script><script src="/js/chaffle.min.js"></script><script src="/js/core/main.js"></script><script src="/js/core/search.js"></script><script src="/js/core/initialization.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.6/katex.min.css"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/vs2015.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/colors/std.css"><link rel="stylesheet" href="/css/colors/white.css"><link rel="stylesheet" href="/css/colors/night.css"><link rel="stylesheet" href="/css/colors/trans.css"><link rel="stylesheet" href="/css/special/special.css"><link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Yurchiu's Blog" type="application/atom+xml"></head><body style="background-image:url(/img/new-bgp.jpg)"><div id="YurLoading" class="YurLoading"><div class="inner"><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div><div class="line-wrap"><div class="line"></div></div></div></div><div class="topbar"><a onclick="topbarToggle()" class="topbar-menu" style="cursor:pointer"><i class="fa fa-bars"></i> </a><a href="/" class="topbar-title"><i class="fa fa-home"></i> Yurchiu's Blog </a><a target="_blank" rel="noopener" href="https://github.com/yz-hs" class="topbar-title"><i class="fa fa-github"></i></a></div><div id="article-container"><div class="sidebar"><div class="avatar-container"><img src="/img/new-avatar.jpg" class="avatar revolve"></div><div class="sidebar-author">Yurchiu<br><span class="mini-text">An AFO whker.</span></div><div class="sidebar-list-container"><div style="height:10px"></div><a class="list-group-item" href="/"><div><i class="fa fa-home fa-fw"></i>&nbsp; 首页</div><div class="badge"></div></a><a class="list-group-item" href="/archives/"><div><i class="fa fa-tasks fa-fw"></i>&nbsp; 归档</div><div class="badge">157</div></a><a class="list-group-item" href="/tags/"><div><i class="fa fa-tags fa-fw"></i>&nbsp; 标签</div><div class="badge">69</div></a><a class="list-group-item" href="/categories/"><div><i class="fa fa-th-large fa-fw"></i>&nbsp; 分类</div><div class="badge">13</div></a><a class="list-group-item" href="/somepage/mood/"><div><i class="fa fa-photo fa-fw"></i>&nbsp; 说说</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/about/"><div><i class="fa fa-user-o fa-fw"></i>&nbsp; 关于</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/chat/"><div><i class="fa fa-commenting-o fa-fw"></i>&nbsp; 留言</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/link/"><div><i class="fa fa-link fa-fw"></i>&nbsp; 链接</div><div class="badge"></div></a><a class="list-group-item" href="/somepage/settings/"><div><i class="fa fa-cog fa-fw"></i>&nbsp; 设置</div><div class="badge"></div></a><div style="height:200px"></div></div><div class="sidebar-footer"><div class="item" id="back2Top" data-bs-toggle="tooltip" title="顶部"><i class="fa fa-arrow-circle-up"></i></div><div class="item" data-bs-toggle="tooltip" title="RSS"><a href="/atom.xml"><i class="fa fa-feed"></i></a></div><div class="item" data-bs-toggle="tooltip" title="搜索"><a href="/somepage/search/"><i class="fa fa-search"></i></a></div></div></div><div class="article"><div class="vertical fake-sidebar"></div><div class="vertical post"><div class="header"><h1 class="title">P5659 [CSP-S2019] 树上的数</h1><div class="meta"><span><i class="fa fa-user-o"></i> Yurchiu </span><span><i class="fa fa-clock-o"></i> 2021-08-12, 00:59:12</span> <span><i class="fa fa-font"></i> 8.4k</span> <span class="hideBars" onclick="hideBars()"><i class="fa fa-eye-slash"></i> 隐藏左右两栏 </span><span class="showBars" onclick="showBars()"><i class="fa fa-eye"></i> 展示左右两栏</span></div></div><div class="breadcrumb"><div class="url"><a href="/"><i class="fa fa-home"></i> 首页</a> / P5659 [CSP-S2019] 树上的数</div><div class="share">分享到 <a target="_blank" rel="noopener" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://yz-hs.github.io/46fe69313ce6/&title=P5659 [CSP-S2019] 树上的数&site=https://yz-hs.github.io"><i class="fa fa-qq"></i></a></div></div><div class="post-text"><p>这是 Yurchiu 讲课用的讲义。因为是用 Markdown 写的，所以可以直接复制在这里。</p><h1 id="p5659-csp-s2019-树上的数"><a class="markdownIt-Anchor" href="#p5659-csp-s2019-树上的数"></a> P5659 [CSP-S2019] 树上的数</h1><h2 id="闲话"><a class="markdownIt-Anchor" href="#闲话"></a> 闲话</h2><ul><li><p>既然我们又分到了一个黑题，自然要创新一下讲课形式——不用 PPT，而是用讲义！</p><p>或者说，因为这个题兼具思维难度性和代码复杂性，而 PPT 的形式不方便展示代码，所以就用了这个形式。</p></li><li><p>然后<s>除非大佬们开了防火墙</s>，“文件接收柜”里面应该已经有了今天讲课的资源包。</p></li><li><p>本讲义有很多提问环节，如果大佬们同步看的话，请不要偷看答案哦！</p></li><li><p>由于讲课的人水平所限，可能有不清楚或者错误的地方，欢迎指出！</p></li><li><p>插一嘴，Typora 这个 Markdown 编辑器真好用！</p></li></ul><span id="more"></span><h2 id="题意"><a class="markdownIt-Anchor" href="#题意"></a> 题意</h2><p>给定一个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的树，它共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个结点与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 条边，结点从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 编号。初始时每个结点上都有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的数字，且每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的数字都只在<strong>恰好</strong>一个结点上出现。</p><p>接下来你需要进行<strong>恰好</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 次删边操作，每次操作你需要选一条<strong>未被删去</strong>的边，此时这条边所连接的两个结点上的数字将会<strong>交换</strong>，然后这条边将被删去。</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 次操作过后，所有的边都将被删去。此时，按数字从小到大的顺序，将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 所在的结点编号依次排列，就得到一个结点编号的排列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。现在请你求出，在最优操作方案下能得到的<strong>字典序最小</strong>的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</p><p><img src="https://cdn.jsdelivr.net/gh/yz-hs/PicGo/%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0%20(4).png" alt=""></p><p>如上图，蓝圈中的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">1 \sim 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span></span></span></span>​​ 一开始分别在结点 ②，①，③，⑤，④。按照 (1)，(4)，(3)，(2) 的顺序删去所有边，树变为下图。按数字顺序得到的结点编号排列为 ①③④②⑤，该排列是所有可能的结果中字典序最小的。</p><p><img src="https://cdn.jsdelivr.net/gh/yz-hs/PicGo/%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0%20(1).png" alt=""></p><h2 id="数据范围"><a class="markdownIt-Anchor" href="#数据范围"></a> 数据范围</h2><table><thead><tr><th style="text-align:left">测试点编号</th><th style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo></mrow><annotation encoding="application/x-tex">n \leq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span></span></span></span></th><th style="text-align:left">特殊性质</th></tr></thead><tbody><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">1 \sim 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">无</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>∼</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3 \sim 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>160</mn></mrow><annotation encoding="application/x-tex">160</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">树的形态是一条链</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>∼</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">5 \sim 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">7</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>∼</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">8 \sim 9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">8</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">9</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>160</mn></mrow><annotation encoding="application/x-tex">160</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">存在度数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的结点</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>∼</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">10 \sim 12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">2</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">同上</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>13</mn><mo>∼</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">13 \sim 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>160</mn></mrow><annotation encoding="application/x-tex">160</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">无</td></tr><tr><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>17</mn><mo>∼</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">17 \sim 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span></span></span></span></td><td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></td><td style="text-align:left">无</td></tr></tbody></table><p>对于所有测试点：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>T</mi><mo>≤</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1 \leq T \leq 10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8193em;vertical-align:-.13597em"></span><span class="mord mathnormal" style="margin-right:.13889em">T</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，保证给出的是一个树。</p><details><summary>点击查看题解</summary><h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2><p>本题解是把 luogu 的各个题解缝在一块，而形成的题解。<s>我是裁缝</s>。</p><h3 id="0x00-前置知识"><a class="markdownIt-Anchor" href="#0x00-前置知识"></a> 0x00 前置知识</h3><ul><li>生成全排列</li><li>并查集</li><li>链表</li><li>贪心</li></ul><h4 id="生成全排列"><a class="markdownIt-Anchor" href="#生成全排列"></a> 生成全排列</h4><p>这个我们不必多说吧，诸位大佬肯定都会。通俗来讲，就是通过 dfs 在每一位填数字。</p><h4 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h4><p>建议看某菜鸡的 Blog。</p><ul><li><a href="/2a969ab32552/">link1</a>，以模板为主。</li><li><a href="/bcc33af415e1/">link2</a>，以例题为主。</li></ul><h4 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h4><p>一般而言链表都是用指针写的，<s>用数组模拟有你好受的</s>。而指针是个神奇的东西，<s>对初学者极不友好</s>。<s>其实也没啥好说的，就问问你当年是怎么理解链式前向星的</s>。</p><p>主要有以下几点：</p><ul><li>存储每个节点的地址，且每个节点都有后继的地址；</li><li>必要时也可以储存指向自己前驱的地址；</li><li>用指针时要注意边界的判断。</li></ul><p><s>话说大家真的彻底明白链式前向星的工作原理了吗，当初为了理解这东西我费了九牛二虎之力</s>。</p><p>其实本题可以用链表做。由于时间有限，赶不出利用链表实现的代码。</p><h4 id="贪心"><a class="markdownIt-Anchor" href="#贪心"></a> 贪心</h4><p>可以当作进阶的 DP。然而，这需要严格证明。</p><h3 id="0x01-暴搜"><a class="markdownIt-Anchor" href="#0x01-暴搜"></a> 0x01 暴搜</h3><p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo>×</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n!\times n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>​​​​​​ 的时间复杂度，得到删边顺序的全排列，再进行模拟，更新答案。这样您就可以得到 10 分了（考场很少有能超过 10 分的人，可以认为是考场满分解）。</p><p>相信大家都会生成全排列吧（<s>不会吧不会吧，不会真有人不会吧</s>）。</p><p>想拿这 10 分，可不容易。一些注意事项：</p><ul><li><p>注意输入输出格式**。做题不审题不是好习惯**。</p><blockquote><p>第二行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \leq i \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.78041em;vertical-align:-.13597em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.79549em;vertical-align:-.13597em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span>） 个整数表示<strong>数字</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">i</span></span></span></span>​​ 初始时所在的<strong>结点编号</strong>。</p><p>将数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \sim n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> <strong>所在的结点编号</strong>依次排列，就得到一个<strong>结点编号的排列</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。求出在最优操作方案下能得到的<strong>字典序最小</strong>的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。</p></blockquote></li><li><p>注意模拟时，交换的是一条边两端的数字，所以注意枚举的是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 的全排列，交换也是枚举到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。</p></li></ul><p>下面是代码。</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">namespace</span> Force<span class="hljs-comment">//暴力 </span>
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll u,v;&#125;e[N*<span class="hljs-number">2</span>];
	ll n,num[N],vis[N],a[N],ans[N],tmp[N],ump[N];
	<span class="hljs-comment">//P 是排列 </span>
	<span class="hljs-comment">//点的个数 点上的数字 生成P要用到 P 最小的P 点上的数字 数字所在编号 </span>
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			tmp[i]=num[i];<span class="hljs-comment">//因为下面要用到 num，所以复制一遍防止出锅 </span>
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//注意是边的全排列 </span>
			<span class="hljs-built_in">swap</span>(tmp[e[a[i]].u],tmp[e[a[i]].v]);<span class="hljs-comment">//按照题意 ~~膜你~~ 模拟 </span>
		ll flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//判断是否更新答案 </span>
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			ump[tmp[i]]=i;<span class="hljs-comment">//注意判断字典序是以数字为序，点的编号的排列 </span>
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//判断字典序的大小 </span>
		&#123;
			<span class="hljs-keyword">if</span>(ump[i]&gt;ans[i]) &#123;flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//这种特性启发了我们 </span>
			<span class="hljs-keyword">if</span>(ump[i]&lt;ans[i]) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//在后面可以利用贪心求解 </span>
		&#125;
		<span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans[i]=ump[i];<span class="hljs-comment">//更新答案 </span>
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll step)</span><span class="hljs-comment">//必会技能：生成全排列 </span>
	</span>&#123;
		<span class="hljs-keyword">if</span>(step&gt;=n)
		&#123;
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
		&#123;
			<span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;
			vis[i]=<span class="hljs-number">1</span>;a[step]=i;
			<span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);
			vis[i]=<span class="hljs-number">0</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a);
				num[a]=i;<span class="hljs-comment">//注意题目输入格式，对于正解来说比较方便 </span>
				ans[i]=inf;
			&#125;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				e[i].u=a,e[i].v=b;
			&#125;
			<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
</code></pre><h3 id="0x02-菊花图"><a class="markdownIt-Anchor" href="#0x02-菊花图"></a> 0x02 菊花图</h3><p>菊花图有一些比较友好的特性。设菊花图的花心是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>​，与其相邻的点是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>。发现在删边时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 固定了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 的值（因为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>，与其他的点没有任何关系，既然边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>x</mi><mi>i</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;u,x_i&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.7335400000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span> 被删掉了，那么这个点的数值也就不会被改变了），而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 原先的值到了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>​​，等待下一次被固定。</p><p>结合下面的动图进行理解。</p><p><img src="https://cdn.jsdelivr.net/gh/yz-hs/PicGo/%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0%20(1).gif" alt=""></p><p>容易发现，这个过程有点像一个<strong>环</strong>。假如将拆边描述为一个排列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>p</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">p_1,p_2,...,p_{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.638891em;vertical-align:-.208331em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span></span></span></span>​（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo separator="true">,</mo><msub><mi>p</mi><mi>i</mi></msub><mo>≠</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">\forall1\le i&lt;n ,p_i\not=u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.83041em;vertical-align:-.13597em"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69862em;vertical-align:-.0391em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>​）​，也就是说，你按顺序拆掉了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>p</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,p_1),(u,p_2),..,(u,p_{n-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​，那么最后，原来根上的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>u</mi></msub></mrow><annotation encoding="application/x-tex">a_u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.58056em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>​ 会去到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>​，原来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.31166399999999994em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>​ 上的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><msub><mi>p</mi><mi>i</mi></msub></msub></mrow><annotation encoding="application/x-tex">a_{p_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3280857142857143em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span>​ 会去到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">p_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.638891em;vertical-align:-.208331em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span></span></span></span>​，原来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">p_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>​ 上的数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><msub><mi>p</mi><mi>n</mi></msub></msub></mrow><annotation encoding="application/x-tex">a_{p_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.716668em;vertical-align:-.286108em"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.15139200000000003em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.16454285714285719em"><span style="top:-2.357em;margin-left:0;margin-right:.07142857142857144em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.143em"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span></span></span></span>​ 会去到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>​。如果我们将点按照 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>p</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,p_1,p_2,\dots,p_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="minner">…</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​​ 的顺序排成一个环的话，整个操作就相当于将每个点上的数字向后移了一位。</p><p>而本题目标肯定是尽量把最小的数字给转移到最小的编号上，而且转移的方案（即转移路线）有且仅有一个。</p><p>于是很容易地想到一个<strong>贪心</strong>的构造环（构造拆边顺序）的方法。</p><p><strong>按照 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1,2,3,...,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span></span></span></span>​​​​​​（数字）​​​​​ 的顺序，每个数字从自己所在的点选择在环上面的下一个点（就是说这个数字要搬运到哪里）。那么每次在合法的情况下选标号最小的节点即可</strong>。这个方法非常重要，因为后面的解都用到了这个思路。</p><p>那如何判断合法呢？</p><p>建一个新图。把“搬运点”的过程，当做是连边。就像动图一样，如果一个点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 上的数字要搬运到点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span>，就在新图上连一条<strong>有向边</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;x,y&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.7335400000000001em;vertical-align:-.19444em"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span>。我们容易发现，一个点只能最多有一条入边，一条出边，这样才是合法的。比如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x\rightarrow y\rightarrow z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">→</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 是合法的，因为点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 上的数字到达点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 上的数字又正好到达了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span>，就可以到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 了。如果从一个点发出多个有向边，或多个有向边指向一个点，这很明显是不合法的。</p><p>相信各位大佬都已经看出来了，这样在新图中会出现许多链。并且，在最后还会形成一个大环。这样，就和我们前面所述的拆边过程契合了。</p><p>所以，在环还没有封闭的时候，请注意它们都还是一些链，所以不要出现提前成环<s>提前自闭</s>的情况，并保证最后会出现一个大环而不是若干个小环。</p><p>利用用并查集维护，方便地判断是否成环。</p><p>下面是代码。时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">namespace</span> Flower
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span><span class="hljs-comment">//并查集 </span>
	&#123;
  		ll dad[N],n;
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
    	<span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span><span class="hljs-comment">//非递归写法，你值得拥有 </span>
    	</span>&#123;   
           	<span class="hljs-keyword">while</span>(x!=dad[x])
            	x=dad[x]=dad[dad[x]];<span class="hljs-comment">//路径压缩 </span>
         	<span class="hljs-keyword">return</span> x;
    	&#125;
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
           ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
           dad[d1]=d2;
           <span class="hljs-keyword">return</span>;
    	&#125;	
    	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
           ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
           <span class="hljs-keyword">if</span>(d1==d2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    	&#125;
	&#125;U;
	ll n,num[N],id[N],vis[N],ans[N];
	<span class="hljs-comment">//结点数 点上的数字 数字所在编号 是否访问过 </span>
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		U.<span class="hljs-built_in">init</span>(n);
		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));
		<span class="hljs-comment">//对于新图来说，vis 数组防止出现一个点连到链的中间的情况 </span>
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//枚举数字 </span>
		&#123;
			<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//贪心地选编号小的点 </span>
			&#123;
				<span class="hljs-keyword">if</span>(vis[j]||(i!=n&amp;&amp;U.<span class="hljs-built_in">check</span>(id[i],j))) <span class="hljs-keyword">continue</span>;
				<span class="hljs-comment">//首先保证不要破坏链，或者说重复搬运到一个点</span>
				<span class="hljs-comment">//其次不要使链提前自闭（当枚举到最后一个时就可以自闭了） </span>
				ans[i]=j;vis[j]=<span class="hljs-number">1</span>;U.<span class="hljs-built_in">merge</span>(j,id[i]);<span class="hljs-keyword">break</span>;
				<span class="hljs-comment">//加入有向边 &lt;id[i],j&gt; 表示删边的先后与相邻关系</span>
				
				<span class="hljs-comment">//由于并查集的特性（或者说我们已经用 vis 数组进行维护了），</span>
				<span class="hljs-comment">//实际上 merge 的两个参数并没有先后关系 </span>
			&#125;
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
				num[id[i]]=i;
			&#125;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//好像连图都没用到 </span>
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
			<span class="hljs-built_in">solve</span>(); 
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125; 
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
</code></pre><p>想必各位大佬已经发现了，读进来的图似乎压根没用到！<s>除了骗分</s>。</p><p>原因是，我们对于菊花图上的所有节点，都是一视同仁的。节点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 也是符合“一个点只能最多有一条入边，一条出边”的限制的。</p><h3 id="0x03-链"><a class="markdownIt-Anchor" href="#0x03-链"></a> 0x03 链</h3><p>链有一些比较友好的特性。它是一条类似于线的东西；除了两个端点之外，其他的点度都为 2。</p><p>由于特性 1，我们可以以数组的形式方便地进行处理。我们先找到链首（度为 1 的点），进行 dfs，利用 dfs 序来得到点在链中的先后次序，进行处理。</p><p>由于特性 2，先抛开特殊的端点不谈，每个点都有两条边相邻。可以保证的是，两条边的删除次序是有时间的先后的。所以我们可以想到，给每个点一个标记，标记左右两边的删除次序，或者说优先级（无限制或未知，左先右后，左后右先）。这里的优先级实际上就是一种拓扑序。</p><blockquote><p>提问一下：比如说左先右后，一定是左面的边删掉后接着就删右面的边吗？</p></blockquote><p>下面举个例子来说明这个优先级。</p><p><img src="https://cdn.jsdelivr.net/gh/yz-hs/PicGo/%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0%20(2).png" alt=""></p><p>比如说在 2 上面的<strong>数字</strong>要去 5：</p><ul><li>它离开 2 时，需要保证边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;2,3&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span> 在边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;1,2&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span> 之前先被删，否则它就跑到 1 上面去了。</li><li>在它被运送途中，需要保证边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;2,3&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;3,4&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;4,5&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span> 被先后删除，不能颠倒。</li><li>它到达 5 时，需要保证边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;5,6&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">6</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span> 在边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;4,5&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5782em;vertical-align:-.0391em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8388800000000001em;vertical-align:-.19444em"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span></span></span></span>​ 之前先被删，否则它就跑到 6 上面去了。</li></ul><p>这是往右走的情况，往左的情况可自行推导，其实不难（这里要提问一下）。</p><p>而最后，我们判定一个方法是否可行，只需要判断它和前面的点的标记是否冲突即可。</p><p>下面是代码。时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>​。</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">namespace</span> Chain
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-type">const</span> ll UnLim=<span class="hljs-number">0</span>,FirS=<span class="hljs-number">1</span>,SecF=<span class="hljs-number">2</span>;
	ll n,id[N],ans[N],deg[N];
	ll dfn[N],link[N],tag[N],cnt=<span class="hljs-number">0</span>;
	<span class="hljs-comment">//结点数 数字所在编号 节点的度</span>
	<span class="hljs-comment">//节点的dfs序 按dfs序排列的节点 按dfs序排列的节点的标记 dfs序的戳 </span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
		ll head[N],cnt;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>
		</span>&#123;
			<span class="hljs-built_in">ms</span>(e);<span class="hljs-built_in">ms</span>(head);
			cnt=<span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b)</span>
		</span>&#123;
			e[++cnt]=(edge)&#123;head[a],b&#125;;
			head[a]=cnt;
		&#125;
	&#125;G;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll root,ll dad)</span>
	</span>&#123;
		dfn[root]=++cnt;
		link[cnt]=root;
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(son==dad) <span class="hljs-keyword">continue</span>;
			<span class="hljs-built_in">dfs</span>(son,root);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			<span class="hljs-keyword">if</span>(deg[i]==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">dfs</span>(i,i);<span class="hljs-keyword">break</span>;&#125;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//枚举数字 </span>
		&#123;
			ll now=dfn[id[i]],des=inf;
			<span class="hljs-comment">//now 是起始点，des 是终止点</span>
			<span class="hljs-comment">//各个变量里面到底存的是什么，一定要分清 </span>
			<span class="hljs-comment">//有什么不明白的地方可以提问！ </span>
			<span class="hljs-comment">/*
			   --0-- now --1-- q --2-- w --3-- e --4-- des --5--
			   0 一定是比 1 后删；1 2 3 4 一定先后删；5 一定比 4 先删。 
			*/</span>
			<span class="hljs-keyword">if</span>(tag[now]!=FirS)<span class="hljs-comment">//向后找目标 </span>
			&#123;
				<span class="hljs-keyword">for</span>(ll j=now+<span class="hljs-number">1</span>;j&lt;=n;j++)
				&#123;
					<span class="hljs-keyword">if</span>(tag[j]!=FirS) des=<span class="hljs-built_in">min</span>(des,link[j]);<span class="hljs-comment">//符合 目的地 的条件，可选 </span>
					<span class="hljs-keyword">if</span>(tag[j]==SecF) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//不符合 继续走 条件，返回 </span>
					<span class="hljs-comment">//这里，提一个问题：上面的两个语句能不能互换？为什么？ </span>
				&#125;
			&#125;
			<span class="hljs-comment">/*
			   --0-- des --1-- q --2-- w --3-- e --4-- now --5--
			   5 一定是比 4 后删；4 3 2 1 一定先后删；0 一定比 1 先删。 
			*/</span>
			<span class="hljs-keyword">if</span>(tag[now]!=SecF)<span class="hljs-comment">//向前找目标 </span>
			&#123;
				<span class="hljs-keyword">for</span>(ll j=now<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)
				&#123;
					<span class="hljs-keyword">if</span>(tag[j]!=SecF) des=<span class="hljs-built_in">min</span>(des,link[j]);<span class="hljs-comment">//符合 目的地 的条件，可选 </span>
					<span class="hljs-keyword">if</span>(tag[j]==FirS) <span class="hljs-keyword">break</span>;<span class="hljs-comment">//不符合 继续走 条件，返回 </span>
				&#125;
			&#125;
			<span class="hljs-keyword">if</span>(dfn[des]&gt;now)<span class="hljs-comment">//目标在后面 </span>
			&#123;
				<span class="hljs-keyword">for</span>(ll j=dfn[des]<span class="hljs-number">-1</span>;j&gt;=now+<span class="hljs-number">1</span>;j--) tag[j]=FirS;<span class="hljs-comment">//一定先后删</span>
				tag[now]=tag[dfn[des]]=SecF;<span class="hljs-comment">//前面的后删 </span>
			&#125;
			<span class="hljs-keyword">if</span>(dfn[des]&lt;now)<span class="hljs-comment">//目标在前面 </span>
			&#123;
				<span class="hljs-keyword">for</span>(ll j=dfn[des]+<span class="hljs-number">1</span>;j&lt;=now<span class="hljs-number">-1</span>;j++) tag[j]=SecF;<span class="hljs-comment">//一定先后删</span>
				tag[now]=tag[dfn[des]]=FirS;<span class="hljs-comment">//后面的后删 </span>
			&#125;
			tag[<span class="hljs-number">1</span>]=tag[n]=UnLim;<span class="hljs-comment">//只有一条边，自然就无所谓了 </span>
			ans[i]=des; 
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			G.<span class="hljs-built_in">clear</span>();
			<span class="hljs-built_in">ms</span>(deg);<span class="hljs-built_in">ms</span>(tag);
			cnt=<span class="hljs-number">0</span>;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				G.<span class="hljs-built_in">add</span>(a,b);G.<span class="hljs-built_in">add</span>(b,a);
				deg[a]++;deg[b]++;
			&#125;
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
</code></pre><h3 id="0x04-正解"><a class="markdownIt-Anchor" href="#0x04-正解"></a> 0x04 正解</h3><div style="text-align:right"><del>本人已死，有事烧纸。</del></div>> 前方核能！由于难度有亿点大，我尝试把 zzy 的语言搬来，使得讲义语言风格更有趣点。<p><s>想必各位巨佬已经不屑于停滞在部分解了</s> 。</p><p>想必各位巨佬已经发现了**：一个点的邻接边抽象成点后，用有向边表示删除先后关系的话，形成的总是一堆链**。这可以通过菊花图认识到这一点。</p><p>想必各位巨佬已经发现了**：只有共用同一个顶点的边才有删除的先后关系**。这可以通过链认识到这一点。</p><p>那么恭喜你，链和菊花的做法对我们硬刚正解有很大的启发（正解细节众多，一部分听不懂也没关系，上面加粗的两句话不明白为什么也没关系，后面会讲。建议结合<s>毒瘤的</s>代码来理解）。</p><hr><p>那么，我们由链维护边的删除次序想到：能否将这样的维护扩展到多条边的情况？其实是可以的<s>不然我为什么要问这个问题</s>。上面已经说了，只有共用同一个顶点的边才有删除的先后关系。</p><p>直接讲有点费事，下面结合图来理解。</p><p><img src="https://cdn.jsdelivr.net/gh/yz-hs/PicGo/%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0%20(3).png" alt=""></p><p>我们要将 1 上的数字搬到 4。容易发现：</p><ul><li>(1) 的优先级是与 1 号点相邻的边中最大的。<s>要不你想搬个寂寞啊</s>。</li><li>(2) 的优先级是与 3 号点相邻的边中最小的。<s>要不到手的鸭子飞了</s>。</li></ul><p>这样对吗？</p><p>不对！</p><p>为什么不对？下面是提问环节！</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mspace width="1em"></mrow><annotation encoding="application/x-tex">\quad</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0;vertical-align:0"></span><span class="mspace" style="margin-right:1em"></span></span></span></span></span></p><p>经过一番研讨，我们发现：</p><ul><li>删完 (1) 接着必须删 (2)。<s>要不它就被别人抢去了</s>。</li></ul><p>我们神奇地发现，这些条件限制，只需每个点都维护边的删除优先级就可以了！换句话说，<strong>只有共用同一个顶点的边才有删除的先后关系</strong>。严谨地说，这些限制都是应用在某一点的几条边中的，因此可以单独考虑每个点的情况。</p><hr><p>想必各位巨佬已经发现了：维护每个点，不就相当于每个点都是菊花图吗？<s>于是就形成了菊花树，一起来看菊花！</s></p><p>是的。我们在做菊花图时，开了个并查集来维护边的删除次序。想必各位巨佬已经知道了：我们要对于每一个点，都要开一个<s>冰茶几</s>并查集！</p><p>那么，对于多个删边的先后关系，我们将它们的边抽象成一个点，删边的先后、紧邻次序抽象成连边，发现它有点像链。</p><p>但是这里有个问题：如果一个点删除边的顺序不一定是连续的怎么办？</p><p>对于这种情况，我们只需要把它们看成有许多个链，但是它们没有接在一起即可。换句话说，<strong>一个点的邻接边抽象成点后，用有向边表示删除先后关系的话，形成的总是一堆链</strong>。</p><hr><p>情况与单链类似，对于一个数字 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span>​ 从起点移动至终点，在路径上有一下几个很重要的性质。有没有大佬总结一下？</p><p>别忘了说为什么。</p><p>可以根据前面所述，提炼一下。</p><p>当大家弄明白之后我们可以继续了。以上一定要明白，<s>下面的得靠自己的修为了</s>。</p><p>揭晓答案——几个很重要的性质：</p><ul><li><strong>对于起点，其出边一定是这一点第一条被删掉的边</strong>。 如果不是，则 k 会被换到其他点上。</li><li><strong>对于终点，其入边一定是这一点最后一条被删掉的边</strong>。 如果不是，则 k 也会被换到其他点上。</li><li><strong>对于中转点，其入边先于出边被删，且在该点的所有边里被删除的顺序是相邻的</strong>。 如果不满足，则在中间，数字 k 会被换到其他点上。</li></ul><hr><p>思路依然是暴力枚举每个数字，从这个数字的初始位置开始 dfs ，检查路径上的点是否可以作为中转点或终点即可。</p><p>这里是这个题的实现中最难的位置，即检查是否满足中转点或终点的条件。这里，使用了并查集来管理边的关系，存储某个点的边的限制连成的链式结构。</p><p>对于”几个很重要的性质“的前两个，我的做法是对每一个并查集建了一个虚点，如果一条边的优先级最大，那么由虚点向它连一条边，如果一条边优先级最小，则由它向虚点连一条边。这样就很好搞了。</p><p>必须上代码，结合代码讲一讲，否则真的难以理解。必要时画图。<s>理解确实得靠自己的修为了</s>。</p><p>时间复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>α</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2\alpha(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">namespace</span> Perfect 
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> for(a) for(register a) </span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">20000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	ll n,id[N],ans[N],deg[N];
	<span class="hljs-comment">//结点数 数字所在编号 答案 节点的度 </span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
	&#123;
		<span class="hljs-comment">//仍一样，并查集维护的是删边顺序，一条有向边 &lt;u,v&gt;</span>
		<span class="hljs-comment">//表示边 u 在边 v 之前删，且相邻 </span>
		<span class="hljs-comment">//可参考菊花图部分进行理解 </span>
		<span class="hljs-comment">//注意 u 和 v 都是原图中的边 </span>
  		ll dad[N],out[N],in[N],n;
		<span class="hljs-comment">//out 是一个点有没有出边，in 同理 </span>
		<span class="hljs-comment">//size 是集合大小，即链的大小 </span>
  		ll size[N];
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll p)</span>
		</span>&#123;
			n=p;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				dad[i]=i;
				out[i]=in[i]=<span class="hljs-number">0</span>; 
				size[i]=<span class="hljs-number">1</span>;
			&#125;
		&#125;
    	<span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span>
    	</span>&#123;
           	<span class="hljs-keyword">while</span>(x!=dad[x])
            	x=dad[x]=dad[dad[x]];
         	<span class="hljs-keyword">return</span> x;
    	&#125;
    	<span class="hljs-comment">//这里不像菊花图的情况，参数不能颠倒 </span>
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
    		<span class="hljs-comment">//加有向边 &lt;x,y&gt; </span>
            ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
            dad[d1]=d2;size[d2]+=size[d1];
            out[x]=in[y]=<span class="hljs-number">1</span>;
		    <span class="hljs-comment">//标记一个点有了入边或出边</span>
		    <span class="hljs-comment">//便于判断加入当前点是否会破坏环 </span>
            <span class="hljs-keyword">return</span>;
    	&#125;	
    	<span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll x,ll y,ll jud)</span><span class="hljs-comment">//简单几行，充满玄机 </span>
    	</span>&#123;
    		<span class="hljs-keyword">if</span>(in[y]||out[x]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    		<span class="hljs-comment">//保证 x 是链尾，y 是链首 </span>
            ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
            <span class="hljs-keyword">if</span>(d1==d2&amp;&amp;size[d1]!=jud) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-comment">//用来判断亿些情况，下面会有大段话来解释 </span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    	&#125;
	&#125;U;<span class="hljs-comment">//实际上对于每个点都开了并查集 </span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
		ll head[N],cnt;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>
		</span>&#123;
			<span class="hljs-built_in">ms</span>(e);<span class="hljs-built_in">ms</span>(head);
			cnt=<span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b)</span>
		</span>&#123;
			e[++cnt]=(edge)&#123;head[a],b&#125;;
			head[a]=cnt;
		&#125;
	&#125;G;
	<span class="hljs-function">ll <span class="hljs-title">dfs1</span><span class="hljs-params">(ll root,ll edge)</span><span class="hljs-comment">//寻径算法 </span>
	</span>&#123;<span class="hljs-comment">//短短 14 行代码，讲明白不容易啊 qwq</span>
	 <span class="hljs-comment">//欢迎观看注释比代码长系列 </span>
		ll ret=n+<span class="hljs-number">1</span>;<span class="hljs-comment">//要返回的目标 </span>
		<span class="hljs-keyword">if</span>(root!=edge&amp;&amp;U.<span class="hljs-built_in">check</span>(edge,root,deg[root]+<span class="hljs-number">1</span>))
		<span class="hljs-comment">//接下来判断这个点能不能当作终点。 </span>
		<span class="hljs-comment">//首先，不是起点才有可能当作终点（废话） </span>
		<span class="hljs-comment">//其次。只有最后一个删边，才能保证这个数字不会跑掉。</span>
		
		<span class="hljs-comment">//这里，root 是个新图虚点，原图虚边，为了保证这个边是最后一个被删掉的。 </span>
		
		<span class="hljs-comment">//分两种情况：</span>
		<span class="hljs-comment">//  - 终边未被指定。此时两者不属于同一链，可以连接，表示指定它最后删除。</span>
		<span class="hljs-comment">//    &gt; check 函数对于不同集合会直接返回 1，表示可行。 </span>
		<span class="hljs-comment">//  - 此边和起始边在同一链上。即它们先后顺序已确定。</span>
		<span class="hljs-comment">//    那么我们必须要保证这个删边顺序组成的链中，长度刚好为这个节点的边数。</span>
		<span class="hljs-comment">//    否则，边不可能删的完。 </span>
		<span class="hljs-comment">//    &gt; check 函数的参数 3 用来判断边数。</span>
		
		<span class="hljs-comment">//加 1 的原因，可以类比菊花图的花心。考虑每个点，其周围的边的删边顺序。</span>
		<span class="hljs-comment">//其删边关系正好是点的度数 +1（想想那个“吃豆人”的动图）。</span>
		<span class="hljs-comment">//实际上，由于虚点的存在，度数应该 +1。 </span>
			ret=<span class="hljs-built_in">min</span>(ret,root);
		<span class="hljs-comment">//可以了，取个最小即可。 </span>
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(edge==i) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//别返祖了</span>
			<span class="hljs-comment">//我们习惯于记录一个点的父亲，其实判断边也行 </span>
			<span class="hljs-keyword">if</span>(U.<span class="hljs-built_in">check</span>(edge,i,deg[root]+<span class="hljs-number">1</span>))
			<span class="hljs-comment">//接下来判断这个点能不能当作中转点。</span>
			
			<span class="hljs-comment">//实际上也当作是找起始边，因为判断条件相同， </span>
			<span class="hljs-comment">//这也是我们 dfs1 传参数刚开始传两个 id[i] 所决定的 </span>
			
			<span class="hljs-comment">//  - 首先保证不是同一链（我们本来就要连啊） </span>
			<span class="hljs-comment">//    &gt; check 函数对于同一链，返回 0。 </span>
			<span class="hljs-comment">//  - 特殊情况：这个边连接两条链，包含起始边和终边。</span>
			<span class="hljs-comment">//    这时一定连，防止提前自闭。 </span>
			<span class="hljs-comment">//    &gt; 由于虚点的存在，实际上 check 函数发现这两条边已经是</span>
			<span class="hljs-comment">//      同一链了，且恰好就是点的度数，也就返回 1 了。 </span>
			<span class="hljs-comment">//      不禁让我感慨：check 函数太妙了，直接解决了这么多情况！ </span>
				ret=<span class="hljs-built_in">min</span>(ret,<span class="hljs-built_in">dfs1</span>(son,i^<span class="hljs-number">1</span>));
			<span class="hljs-comment">//为了方便，异或 1 表示反向边（这是我们连续添加两条有向边决定的）</span>
			<span class="hljs-comment">//也是奇怪的 cnt 从 (n+1)/2*2+1 开始决定的 </span>
		&#125;
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-function">ll <span class="hljs-title">dfs2</span><span class="hljs-params">(ll root,ll edge,ll des)</span><span class="hljs-comment">//更新删边条件（并查集） </span>
	</span>&#123;<span class="hljs-comment">//这些就很好理解了 </span>
		<span class="hljs-keyword">if</span>(root==des)
		&#123;
			U.<span class="hljs-built_in">merge</span>(edge,root);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//为了便于判断到底是要更新哪个路径 </span>
		&#125;
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(edge==i) <span class="hljs-keyword">continue</span>;
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs2</span>(son,i^<span class="hljs-number">1</span>,des))<span class="hljs-comment">//沿路径更新 </span>
			&#123;
				U.<span class="hljs-built_in">merge</span>(edge,i);
				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
		&#123;
			ans[i]=<span class="hljs-built_in">dfs1</span>(id[i],id[i]);
			<span class="hljs-built_in">dfs2</span>(id[i],id[i],ans[i]);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			G.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">ms</span>(deg);
			G.cnt=(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;
			<span class="hljs-comment">//把它变成奇数，且比 n 大</span>
			<span class="hljs-comment">//便于虚边的建立（虚边都是 1~n 的） </span>
			
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				G.<span class="hljs-built_in">add</span>(a,b);G.<span class="hljs-built_in">add</span>(b,a);
				deg[a]++;deg[b]++;
			&#125;
			U.<span class="hljs-built_in">init</span>(G.cnt);<span class="hljs-comment">//依据 cnt 来开并查集 </span>
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	Perfect::<span class="hljs-built_in">main</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;<span class="hljs-comment">//433 行！ </span>
</code></pre><p><s>还活着的人举一下手</s>。</p><h3 id="0x05-总结"><a class="markdownIt-Anchor" href="#0x05-总结"></a> 0x05 总结</h3><p>通过这题大家可以发现，此题正解与部分分是紧密相连的，如果没有对部分分的思考，很难直接想到正解。</p><p>这启发我们当无法直接想到正解时，可以思考一些此题的部分分，找到部分分与正解之间的联系，进而以迂回的方式找到正解。一些人因过于追求正解，直接跳过部分分思考正解，结果反而无法得到正解。</p><p><s>对于我这种蒟蒻来说，只会 10 分的暴搜</s>。</p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><p><s>实在不行就复制，粘贴！恭喜你 A 了此题！</s></p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">namespace</span> Force
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll u,v;&#125;e[N*<span class="hljs-number">2</span>];
	ll n,num[N],vis[N],a[N],ans[N],tmp[N],ump[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			tmp[i]=num[i];
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			<span class="hljs-built_in">swap</span>(tmp[e[a[i]].u],tmp[e[a[i]].v]);
		ll flag=<span class="hljs-number">1</span>;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			ump[tmp[i]]=i;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
		&#123;
			<span class="hljs-keyword">if</span>(ump[i]&gt;ans[i]) &#123;flag=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;&#125;
			<span class="hljs-keyword">if</span>(ump[i]&lt;ans[i]) <span class="hljs-keyword">break</span>;
		&#125;
		<span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">return</span>;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) ans[i]=ump[i];
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll step)</span>
	</span>&#123;
		<span class="hljs-keyword">if</span>(step&gt;=n)
		&#123;
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">return</span>;
		&#125;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
		&#123;
			<span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;
			vis[i]=<span class="hljs-number">1</span>;a[step]=i;
			<span class="hljs-built_in">dfs</span>(step+<span class="hljs-number">1</span>);
			vis[i]=<span class="hljs-number">0</span>;
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a);
				num[a]=i;
				ans[i]=inf;
			&#125;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				e[i].u=a,e[i].v=b;
			&#125;
			<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-keyword">namespace</span> Flower
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span> 
	&#123;
  		ll dad[N],n;
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll p)</span></span>&#123; n=p; <span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++) dad[i]=i; &#125;
    	<span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span>
    	</span>&#123;   
           	<span class="hljs-keyword">while</span>(x!=dad[x])
            	x=dad[x]=dad[dad[x]];
         	<span class="hljs-keyword">return</span> x;
    	&#125;
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
           ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
           dad[d1]=d2;
           <span class="hljs-keyword">return</span>;
    	&#125;	
    	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
           ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
           <span class="hljs-keyword">if</span>(d1==d2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    	&#125;
	&#125;U;
	ll n,num[N],id[N],vis[N],ans[N];
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		U.<span class="hljs-built_in">init</span>(n);
		<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(vis));
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
		&#123;
			<span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=n;j++)
			&#123;
				<span class="hljs-keyword">if</span>(vis[j]||(i!=n&amp;&amp;U.<span class="hljs-built_in">check</span>(id[i],j))) <span class="hljs-keyword">continue</span>;
				ans[i]=j;vis[j]=<span class="hljs-number">1</span>;U.<span class="hljs-built_in">merge</span>(j,id[i]);<span class="hljs-keyword">break</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
				num[id[i]]=i;
			&#125;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
			<span class="hljs-built_in">solve</span>(); 
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125; 
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-keyword">namespace</span> Chain
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">2000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	<span class="hljs-type">const</span> ll UnLim=<span class="hljs-number">0</span>,FirS=<span class="hljs-number">1</span>,SecF=<span class="hljs-number">2</span>;
	ll n,id[N],ans[N],deg[N];
	ll dfn[N],link[N],tag[N],cnt=<span class="hljs-number">0</span>;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
		ll head[N],cnt;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>
		</span>&#123;
			<span class="hljs-built_in">ms</span>(e);<span class="hljs-built_in">ms</span>(head);
			cnt=<span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b)</span>
		</span>&#123;
			e[++cnt]=(edge)&#123;head[a],b&#125;;
			head[a]=cnt;
		&#125;
	&#125;G;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll root,ll dad)</span>
	</span>&#123;
		dfn[root]=++cnt;
		link[cnt]=root;
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(son==dad) <span class="hljs-keyword">continue</span>;
			<span class="hljs-built_in">dfs</span>(son,root);
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			<span class="hljs-keyword">if</span>(deg[i]==<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">dfs</span>(i,i);<span class="hljs-keyword">break</span>;&#125;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
		&#123;
			ll now=dfn[id[i]],des=inf;
			<span class="hljs-keyword">if</span>(tag[now]!=FirS)
			&#123;
				<span class="hljs-keyword">for</span>(ll j=now+<span class="hljs-number">1</span>;j&lt;=n;j++)
				&#123;
					<span class="hljs-keyword">if</span>(tag[j]!=FirS) des=<span class="hljs-built_in">min</span>(des,link[j]);
					<span class="hljs-keyword">if</span>(tag[j]==SecF) <span class="hljs-keyword">break</span>;
				&#125;
			&#125;
			<span class="hljs-keyword">if</span>(tag[now]!=SecF)
			&#123;
				<span class="hljs-keyword">for</span>(ll j=now<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)
				&#123;
					<span class="hljs-keyword">if</span>(tag[j]!=SecF) des=<span class="hljs-built_in">min</span>(des,link[j]);
					<span class="hljs-keyword">if</span>(tag[j]==FirS) <span class="hljs-keyword">break</span>;
				&#125;
			&#125;
			<span class="hljs-keyword">if</span>(dfn[des]&gt;now)
			&#123;
				<span class="hljs-keyword">for</span>(ll j=dfn[des]<span class="hljs-number">-1</span>;j&gt;=now+<span class="hljs-number">1</span>;j--) tag[j]=FirS;
				tag[now]=tag[dfn[des]]=SecF;
			&#125;
			<span class="hljs-keyword">if</span>(dfn[des]&lt;now)
			&#123;
				<span class="hljs-keyword">for</span>(ll j=dfn[des]+<span class="hljs-number">1</span>;j&lt;=now<span class="hljs-number">-1</span>;j++) tag[j]=SecF;
				tag[now]=tag[dfn[des]]=FirS;
			&#125;
			tag[<span class="hljs-number">1</span>]=tag[n]=UnLim;
			ans[i]=des; 
		&#125;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			G.<span class="hljs-built_in">clear</span>();
			<span class="hljs-built_in">ms</span>(deg);<span class="hljs-built_in">ms</span>(tag);
			cnt=<span class="hljs-number">0</span>;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				G.<span class="hljs-built_in">add</span>(a,b);G.<span class="hljs-built_in">add</span>(b,a);
				deg[a]++;deg[b]++;
			&#125;
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-keyword">namespace</span> Perfect 
&#123;
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span>
	<span class="hljs-meta">#<span class="hljs-keyword">define</span> for(a) for(register a) </span>
	<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;
	<span class="hljs-type">const</span> ll N=<span class="hljs-number">20000</span>+<span class="hljs-number">10</span>,inf=<span class="hljs-number">2147483647</span>;
	ll n,id[N],ans[N],deg[N];
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFDS</span>
	&#123;
  		ll dad[N],out[N],in[N],n;
  		ll size[N];
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll p)</span>
		</span>&#123;
			n=p;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
			&#123;
				dad[i]=i;
				out[i]=in[i]=<span class="hljs-number">0</span>; 
				size[i]=<span class="hljs-number">1</span>;
			&#125;
		&#125;
    	<span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll x)</span>
    	</span>&#123;
           	<span class="hljs-keyword">while</span>(x!=dad[x])
            	x=dad[x]=dad[dad[x]];
         	<span class="hljs-keyword">return</span> x;
    	&#125;
    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ll x,ll y)</span>
    	</span>&#123;
            ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
            dad[d1]=d2;size[d2]+=size[d1];
            out[x]=in[y]=<span class="hljs-number">1</span>;
            <span class="hljs-keyword">return</span>;
    	&#125;	
    	<span class="hljs-function">ll <span class="hljs-title">check</span><span class="hljs-params">(ll x,ll y,ll jud)</span>
    	</span>&#123;
    		<span class="hljs-keyword">if</span>(in[y]||out[x]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            ll d1=<span class="hljs-built_in">find</span>(x),d2=<span class="hljs-built_in">find</span>(y);
            <span class="hljs-keyword">if</span>(d1==d2&amp;&amp;size[d1]!=jud) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    	&#125;
	&#125;U;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">graph</span>
	&#123;
		<span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;ll nxt,to;&#125;e[N*<span class="hljs-number">2</span>];
		ll head[N],cnt;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>
		</span>&#123;
			<span class="hljs-built_in">ms</span>(e);<span class="hljs-built_in">ms</span>(head);
			cnt=<span class="hljs-number">0</span>;
		&#125;
		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll a,ll b)</span>
		</span>&#123;
			e[++cnt]=(edge)&#123;head[a],b&#125;;
			head[a]=cnt;
		&#125;
	&#125;G;
	<span class="hljs-function">ll <span class="hljs-title">dfs1</span><span class="hljs-params">(ll root,ll edge)</span>
	</span>&#123;
		ll ret=n+<span class="hljs-number">1</span>;
		<span class="hljs-keyword">if</span>(root!=edge&amp;&amp;U.<span class="hljs-built_in">check</span>(edge,root,deg[root]+<span class="hljs-number">1</span>))
			ret=<span class="hljs-built_in">min</span>(ret,root);
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(edge==i) <span class="hljs-keyword">continue</span>;
			<span class="hljs-keyword">if</span>(U.<span class="hljs-built_in">check</span>(edge,i,deg[root]+<span class="hljs-number">1</span>))
				ret=<span class="hljs-built_in">min</span>(ret,<span class="hljs-built_in">dfs1</span>(son,i^<span class="hljs-number">1</span>));
		&#125;
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-function">ll <span class="hljs-title">dfs2</span><span class="hljs-params">(ll root,ll edge,ll des)</span>
	</span>&#123;
		<span class="hljs-keyword">if</span>(root==des)
		&#123;
			U.<span class="hljs-built_in">merge</span>(edge,root);
			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
		&#125;
		<span class="hljs-keyword">for</span>(ll i=G.head[root];i;i=G.e[i].nxt)
		&#123;
			ll son=G.e[i].to;
			<span class="hljs-keyword">if</span>(edge==i) <span class="hljs-keyword">continue</span>;
			<span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs2</span>(son,i^<span class="hljs-number">1</span>,des))
			&#123;
				U.<span class="hljs-built_in">merge</span>(edge,i);
				<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
			&#125;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
	</span>&#123;
		<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
		&#123;
			ans[i]=<span class="hljs-built_in">dfs1</span>(id[i],id[i]);
			<span class="hljs-built_in">dfs2</span>(id[i],id[i],ans[i]);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
	</span>&#123;
		ll T,a,b;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;T);
		<span class="hljs-keyword">while</span>(T--)
		&#123;
			<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;n);
			G.<span class="hljs-built_in">clear</span>();<span class="hljs-built_in">ms</span>(deg);
			G.cnt=(n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,id+i);
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)
			&#123;
				<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;a,&amp;b);
				G.<span class="hljs-built_in">add</span>(a,b);G.<span class="hljs-built_in">add</span>(b,a);
				deg[a]++;deg[b]++;
			&#125;
			U.<span class="hljs-built_in">init</span>(G.cnt);
			<span class="hljs-built_in">solve</span>();
			<span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)
				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i]);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
		&#125;
		<span class="hljs-keyword">return</span>;
	&#125;
&#125;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	Perfect::<span class="hljs-built_in">main</span>();
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></details><br><hr><img src="/img/end-heart.gif" style="box-shadow:none"><br><blockquote><br>本文作者：Yurchiu<br><br>本文链接：https://yz-hs.github.io/46fe69313ce6/<br><br>版权声明：本博客中所有原创文章除特别声明外，均允许规范转载，转载请注明出处。所有非原创文章，按照原作者要求转载。<br><br></blockquote><br><div class="end-post-meta"><span><a href="/tags/OI"><i class="fa fa-tag"></i> OI</a></span> <span><a href="/tags/暴搜"><i class="fa fa-tag"></i> 暴搜</a></span> <span><a href="/tags/贪心"><i class="fa fa-tag"></i> 贪心</a></span> <span><a href="/tags/毒瘤题"><i class="fa fa-tag"></i> 毒瘤题</a></span> <span><a href="/tags/并查集"><i class="fa fa-tag"></i> 并查集</a></span> <span><a href="/tags/链表"><i class="fa fa-tag"></i> 链表</a></span></div><div class="end-post-meta"><span><i class="fa fa-refresh"></i> 最后更新：2023-08-14, 20:19:47</span></div></div><div class="prevnext"><a class="prev" href="/b50c00ca3042/">上一页</a> <a class="next" href="/beae635198a3/">下一页</a></div><div class="comments"><div id="gitalk-container"></div><script>var gitalk=new Gitalk({clientID:"1c64f04731dad7dcc928",clientSecret:"576bde3af3744ef3d054d3b293d0a0c1fce5087f",repo:"no-code",owner:"yz-hs",admin:["yz-hs"],id:location.pathname,language:"zh-CN",proxy:"https://o.cieu.tk/https://github.com/login/oauth/access_token",distractionFreeMode:!1});gitalk.render("gitalk-container")</script></div><div class="avatar-container" style="padding:50px"><img src="/img/new-avatar.jpg" class="avatar revolve" style="height:12%;width:12%"><div style="text-align:center;margin-top:3%">By Yurchiu.</div></div></div><div class="vertical toolbar"><div class="tab-page"><div class="tabTitle tb-tabTitle"><ul><li class="current"><i class="fa fa-random"></i></li><li><i class="fa fa-refresh"></i></li><li><i class="fa fa-circle-o-notch"></i></li></ul></div><div class="tabContent tb-tabContent"><div><div class="title">随机文章<span class="sidetitle">回味旧文</span></div><div class="item no-lrpadding"><a class="post-link" href="/d24d99489782/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2020 新年贺词</div></div></a><a class="post-link" href="/3f5d366e12dd/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">一个 4 人囚徒困境的必胜策略</div></div></a><a class="post-link" href="/3513c6ef3e31/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">2021，初中毕业</div></div></a><a class="post-link" href="/501647d25831/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">AFO 有感</div></div></a><a class="post-link" href="/ed885af1fef5/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">ASCII 艺术</div></div></a><a class="post-link" href="/dd04c203efa6/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">CSP-J2 游记</div></div></a><a class="post-link" href="/1ed002c31ce3/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">CSP-J1 游记</div></div></a></div></div><div class="hide"><div class="title">最近更新<span class="sidetitle">旧文更新</span></div><div class="item no-lrpadding"><a class="post-link" href="/b1c1608155d2/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">P7078 [CSP-S2020] 贪吃蛇</div></div></a><a class="post-link" href="/1b12e9984a40/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">博弈论</div></div></a><a class="post-link" href="/0e3f9acc1e28/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">【解析几何】齐次化联立</div></div></a><a class="post-link" href="/6c70d3b4b7b8/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">PicGo 使用</div></div></a><a class="post-link" href="/0d102f9a3ef1/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">OI 之旅</div></div></a><a class="post-link" href="/501647d25831/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">AFO 有感</div></div></a><a class="post-link" href="/f4829e127292/"><div class="title_fa"><i class="fa fa-file-text-o fa-border" style="height:30px;border:none"></i><div class="title">小技巧和一些代码</div></div></a></div></div><div class="hide"><div class="title">其他物件<a data-bs-toggle="tooltip" href="javascript: document.body.contentEditable='true';
    document.designMode='on';void(0);" title="彩蛋：点击我，可以编辑本页面！" target="_self" class="sidetitle">杂物收纳</a></div><div style="height:10px"></div><div class="item"><tag style="display:inline-block">Hitokoto</tag><br><br><div id="hitokoto">Yurchiu 说，除了她以外的人都很强！嘤嘤嘤~~</div><script>fetch("https://v1.hitokoto.cn").then(function(t){return t.json()}).then(function(t){$("#hitokoto").html(t.hitokoto+"<br><br><div style='text-align: right;'>——"+t.from+"</div>")}).catch(function(t){console.error(t)})</script></div><div class="item"><div id="timeprogress"></div><script>var myDate=new Date,hours=myDate.getHours(),minutes=myDate.getMinutes(),pro=(minutes=60*hours+minutes)/14.4,innerhtml="        <div class='progress' style='height: 20px'>          <div data-bs-toggle='tooltip'               class='progress-bar'               title='时间已过去了 "+pro.toFixed(2)+"%'               style='width: "+pro+"%;               background-color: #4caf50; color: #fff;'>"+pro.toFixed(0)+"%          </div>        </div>";document.getElementById("timeprogress").innerHTML=innerhtml</script></div></div></div></div><div class="item"><div class="title">博客信息</div><div class="list-group"><div class="list-group-item"><div><i class="fa fa-file-text-o fa-fw"></i> 文章数目</div><div class="badge">157</div></div><div class="list-group-item"><div><i class="fa fa-refresh fa-fw"></i> 最近更新</div><div class="badge">08-14</div></div><div class="list-group-item"><div><i class="fa fa-font fa-fw"></i> 本站字数</div><div class="badge">357.5k</div></div></div></div><div class="post-toc"><div class="title">文章目录</div><div class="post-toc-inner"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#p5659-csp-s2019-%E6%A0%91%E4%B8%8A%E7%9A%84%E6%95%B0"><span class="toc-text">P5659 [CSP-S2019] 树上的数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B2%E8%AF%9D"><span class="toc-text">闲话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E6%84%8F"><span class="toc-text">题意</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4"><span class="toc-text">数据范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">0x00 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-text">生成全排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-text">贪心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-%E6%9A%B4%E6%90%9C"><span class="toc-text">0x01 暴搜</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-%E8%8F%8A%E8%8A%B1%E5%9B%BE"><span class="toc-text">0x02 菊花图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-%E9%93%BE"><span class="toc-text">0x03 链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-%E6%AD%A3%E8%A7%A3"><span class="toc-text">0x04 正解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-%E6%80%BB%E7%BB%93"><span class="toc-text">0x05 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li></ol></div></div><script>$(function(){var i=$(".tb-tabTitle>ul>li"),n=$(".tb-tabContent>div");i.click(function(){var t=$(this);setTimeout(function(){t.addClass("current").siblings().removeClass("current");var i=t.index();n.eq(i).show().siblings().hide()})})})</script></div></div><div class="footer"><p class="text-left">©2019-2023 <a target="_blank" rel="noopener" href="https://github.com/yz-hs">Yurchiu</a>. All rights reserved.</p><p class="text-right">Theme <a target="_blank" rel="noopener" href="https://github.com/yz-hs/cutie">Cutie</a>, by Yurchiu.</p></div><div class="natsuki-container" style="width:140px" data-bs-toggle="tooltip" title="Don't touch me! qwq"><img id="natsuki2" width="100%" height="100%" src="/img/natsuki2.png"> <img id="natsuki1" width="100%" height="100%" src="/img/natsuki1.png"></div><script type="text/javascript">$("#natsuki1").click(function(){$("#natsuki1").hide(),$("#natsuki2").show(),$("#natsuki2").css("animation","natsuki 0.55s cubic-bezier(0, 0, 0, 1)")}),$("#natsuki2").each(function(){$(this)[0].addEventListener("animationend",function(){$("#natsuki2").hide(),$("#natsuki1").show(),$(this).css("animation","")})})</script><script>readData("special")||$("html").addClass("none")</script><script>readData("color")||$("html").addClass("color-white"),$("img").attr("onerror","this.src='/img/error.jpg';this.onerror=null"),initialization()</script></div><meting-js class="meting-js appear" fixed="ture" server="netease" type="playlist" id="8524070964"></meting-js><script>consolePrint(),HideIt()</script><script src="/js/ctitle.js"></script><script src="/js/clicklove.js"></script></body></html>